<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Variance-reduced Monte Carlo simulation of phonon transport in silicon films</title>
    <url>/2023/11/MC-silicon-film/</url>
    <content><![CDATA[<p>The variance-reduced Monte Carlo simulation of phonon transport
solves the following equation:</p>
<p><span class="math display">\[
\frac{\partial e^{\text{d}}}{\partial t} + \boldsymbol{v}_{\mathrm{g}}
\cdot \nabla e^{\text{d}} = -\frac{e^{\mathrm{d}} -
(e^{\mathrm{eq}}(T)-e^{\mathrm{eq}}(T_{\mathrm{eq}}))}{\tau}
\]</span></p>
<p>Here, relaxation time approximation is used, and <span
class="math inline">\(\tau\)</span> takes <em>ab initio</em> calculated
value, see <a href="/2023/10/anharmonicity">the previous post</a>. In
this equation, <span class="math inline">\(e^{\mathrm{d}} = \hbar\omega
(f(\omega)-f_{\mathrm{BE}}(\omega, T_{\mathrm{eq}}))\)</span> for each
phonon mode, where <span class="math inline">\(f\)</span> is the
distribution function (not necessarily equilibrium). While <span
class="math inline">\(e^{\mathrm{eq}}(T)=\hbar\omega
(f_{\mathrm{BE}}(\omega, T)-f_{\mathrm{BE}}(\omega,
T_{\mathrm{eq}}))\)</span> follows the Bose-Einstein distribution. Note
that here <span class="math inline">\(T_{\mathrm{eq}}\)</span> is a
reference temperature, and <span class="math inline">\(T\)</span> is the
local temperature that deviates from <span
class="math inline">\(T_{\mathrm{eq}}\)</span>.</p>
<span id="more"></span>
<h1 id="method">Method</h1>
<p>To solve the above equation in a Monte Carlo way, we need to
understand the meaning of each sampling step. The traditional Monte
Carlo is easy to understand, which simulates the original phonon
BTE:</p>
<p><span class="math display">\[
\frac{\partial f}{\partial t} + \boldsymbol{v}_{\mathrm{g}} \cdot \nabla
f = -\frac{f - f_{\mathrm{eq}}(T)}{\tau}
\]</span></p>
<p>and it is direct that each sample represents a fixed amount of
phonons. Analogously, in the energy-based variance-reduced formulation,
each sample represents a fixed amount of energy, and please keep that in
mind, which is important for understanding the rules of initialization.
Also, it is also worth noting that <span
class="math inline">\(e^{\mathrm{d}}\)</span> can be positive or
negative, and that will give each sampled phonon a sign of energy.</p>
<p>To put things simple enough, here we just consider the cross-plane
transport of a silicon film. In that case, only temperature boundaries
are considered.</p>
<img src="/images/2023/MC-silicon-film/model.png" class="" width="400" title="Model">
<h2 id="phonon-initialization">Phonon initialization</h2>
<p>To draw a phonon for the start, we have to make sure that the
boundary and initial conditions are met. For the temperature boundaries,
one thing that we are sure is that, from <span
class="math inline">\(t=0\)</span> to <span
class="math inline">\(t_{\mathrm{total}}\)</span>, the total energy
input from the left boundary is:</p>
<p><span class="math display">\[
E_{\mathrm{left}} = t_{\text{total}}\sum_{\boldsymbol{q}s, \text{ s.t. }
v_{gx}&gt;0} \hbar\omega f(\omega, T_{\text{left}}) v_{gx}
\]</span></p>
<p>thus the deviated energy is:</p>
<p><span class="math display">\[
E_{\mathrm{left}}^{\mathrm{d}} = t_{\text{total}}\sum_{\boldsymbol{q}s,
\text{ s.t. } v_{gx}&gt;0} \underbrace{\hbar\omega (f(\omega,
T_{\text{left}})-f(\omega, T_{\text{eq}}))}_{\approx c_{\boldsymbol{q}s}
\Delta T_{\text{left}}} v_{gx}
\]</span></p>
<p>And the right boundary is the same:</p>
<p><span class="math display">\[
E_{\mathrm{right}}^{\mathrm{d}} = t_{\text{total}}\sum_{\boldsymbol{q}s,
\text{ s.t. } v_{gx}&lt;0} \underbrace{\hbar\omega (f(\omega,
T_{\text{right}})-f(\omega, T_{\text{eq}}))}_{\approx
c_{\boldsymbol{q}s} \Delta T_{\text{right}}} v_{gx}
\]</span></p>
<p>For the internal area, the story is not the same, as the deviated
energy does nothing with the time <span
class="math inline">\(t_{\text{total}}\)</span>, and it is only related
to the initial temperature:</p>
<p><span class="math display">\[
E_{\mathrm{internal}}^{\mathrm{d}} = \sum_{\boldsymbol{q}s} \hbar\omega
(f(\omega, T_{\text{init}})-f(\omega, T_{\text{eq}})) L \approx
\sum_{\boldsymbol{q}s} c_{\boldsymbol{q}s} \Delta T_{\text{init}} L
\]</span></p>
<p>Recall that each sample represents a fixed amount of energy, we
should thus draw each phonon mode according to their contribution to the
total deviated energy. It makes the things worse as the deviated energy
can be positive or negative, but the good thing is that we can add an
abosolute value. That leads to the following strategy:</p>
<ol type="1">
<li>If we want to study <span class="math inline">\(N\)</span> phonons
in the simulation, we should calculate the energy that each phonon we
draw should have, which is <span
class="math inline">\(\frac{|E_{\mathrm{left}}^{\mathrm{d}}| +
|E_{\mathrm{internal}}^{\mathrm{d}}| +
|E_{\mathrm{right}}^{\mathrm{d}}|}{N}\)</span>. This is the abosolute
value, and the sign will be determined later.</li>
<li>Draw a random number <span class="math inline">\(r\)</span> from
<span class="math inline">\([0, 1]\)</span>:
<ol type="1">
<li>If <span class="math inline">\(r &lt;
\frac{|E_{\mathrm{left}}^{\mathrm{d}}|}{|E_{\mathrm{left}}^{\mathrm{d}}|
+ |E_{\mathrm{internal}}^{\mathrm{d}}| +
|E_{\mathrm{right}}^{\mathrm{d}}|}\)</span>, the phonon is drawn from
the left boundary:
<ul>
<li>Draw the phonon mode according to its contribution to <span
class="math inline">\(E_{\mathrm{left}}^{\mathrm{d}}\)</span>, thus the
probability is proportional to <span
class="math inline">\(c_{\boldsymbol{q}s}v_{\boldsymbol{q}s}\)</span>,
but make sure that <span
class="math inline">\(v_{gx}&gt;0\)</span>.</li>
<li>The sign of the energy is determined by the sign of <span
class="math inline">\(E_{\mathrm{left}}^{\mathrm{d}}\)</span>.</li>
</ul></li>
<li>If <span
class="math inline">\(\frac{|E_{\mathrm{left}}^{\mathrm{d}}|}{|E_{\mathrm{left}}^{\mathrm{d}}|
+ |E_{\mathrm{internal}}^{\mathrm{d}}| +
|E_{\mathrm{right}}^{\mathrm{d}}|} \leq r &lt;
\frac{|E_{\mathrm{left}}^{\mathrm{d}}| +
|E_{\mathrm{internal}}^{\mathrm{d}}|}{|E_{\mathrm{left}}^{\mathrm{d}}| +
|E_{\mathrm{internal}}^{\mathrm{d}}| +
|E_{\mathrm{right}}^{\mathrm{d}}|}\)</span>, the phonon is drawn from
the internal area:
<ul>
<li>Draw the phonon mode according to its contribution to <span
class="math inline">\(E_{\mathrm{internal}}^{\mathrm{d}}\)</span>, thus
the probability is proportional to <span
class="math inline">\(c_{\boldsymbol{q}s}\)</span>.</li>
<li>Draw another number to determine the initial position of the
phonon.</li>
<li>The sign of the energy is determined by the sign of <span
class="math inline">\(E_{\mathrm{internal}}^{\mathrm{d}}\)</span>.</li>
</ul></li>
<li>If <span class="math inline">\(r \geq
\frac{|E_{\mathrm{left}}^{\mathrm{d}}| +
|E_{\mathrm{internal}}^{\mathrm{d}}|}{|E_{\mathrm{left}}^{\mathrm{d}}| +
|E_{\mathrm{internal}}^{\mathrm{d}}| +
|E_{\mathrm{right}}^{\mathrm{d}}|}\)</span>, the phonon is drawn from
the right boundary:
<ul>
<li>Draw the phonon mode according to <span
class="math inline">\(E_{\mathrm{right}}^{\mathrm{d}}\)</span>, thus the
probability <span class="math inline">\(\propto
c_{\boldsymbol{q}s}v_{\boldsymbol{q}s}\)</span>, but make sure that
<span class="math inline">\(v_{gx}&lt;0\)</span>.</li>
</ul></li>
</ol></li>
<li>Determine the initial time of the phonon, which is drawn uniformly
from <span class="math inline">\([0, t_{\mathrm{total}}]\)</span>.</li>
</ol>
<h2 id="phonon-advection-and-scattering">Phonon advection and
scattering</h2>
<p>After initialized a phonon, we need to advect it and scatter it. We
first have to determine when the phonon will be scattered. Due to the
scattering time <span
class="math inline">\(\tau_{\boldsymbol{q}s}\)</span>, we draw a random
scattering time <span class="math inline">\(t_{\mathrm{scat}}\)</span>
following the Poisson process. Draw a random number <span
class="math inline">\(r\)</span> from <span class="math inline">\([0,
1]\)</span>, and the scattering time is:</p>
<p><span class="math display">\[
t_{\mathrm{scat}} = -\tau_{\boldsymbol{q}s} \log r
\]</span></p>
<p>Before the scattering, the phonon is advected according to its group
velocity. Once the phonon goes beyond the boundary, it is removed from
the simulation. If the phonon is scattered, we need to draw a new phonon
mode, but keeps the same amount and sign of energy. The new phonon mode
is drawn according to the scattering probability:</p>
<p><span class="math display">\[
P_{\boldsymbol{q}s} \propto
\frac{c_{\boldsymbol{q}s}}{\tau_{\boldsymbol{q}s}}
\]</span></p>
<div class="note primary"><p>The key is to understand why we draw phonon from <span
class="math inline">\(c_{\boldsymbol{q}s}\)</span> inside the area and
from <span
class="math inline">\(c_{\boldsymbol{q}s}v_{\boldsymbol{q}s}\)</span> at
the boundaries for initialization, but draw phonon from <span
class="math inline">\(c_{\boldsymbol{q}s}/\tau_{\boldsymbol{q}s}\)</span>
for scattering. For the initialization, always keep in mind that each
sample represents a fixed amount of energy, thus we need to draw phonon
according to their contribution to the total deviated energy. For the
scattering, the key is to understand the source term in the BTE, which
is <span class="math inline">\(\left(-\frac{e^{\mathrm{d}} -
(e^{\mathrm{eq}}(T)-e^{\mathrm{eq}}(T_{\mathrm{eq}}))}{\tau_{\boldsymbol{q}s}}\right)\)</span>,
and the first term controls the annihilation, the second term thus
controls the creation, which is proportional to <span
class="math inline">\(c_{\boldsymbol{q}s}/\tau_{\boldsymbol{q}s}\)</span>.</p>
<p>It is also important to understand why each phonon is deleted once it
goes beyond the boundary. This is because, (take the left boundary as an
example) we have already considered <strong>all energy goes from left to
right</strong>, and if the phonon bounces back or diffuses back, it will
be counted twice.</p>
</div>
<h1 id="results">Results</h1>
<h2 id="l200mathrmnm-strong-size-effect"><span
class="math inline">\(L=200\,\mathrm{nm}\)</span>: strong size
effect</h2>
<img src="/images/2023/MC-silicon-film/200nm.png" class="" width="400" title="200 nm">
<p>The "Fourier" lines are calculated by solving the thermal diffusion
equation using <code>fipy</code>. The diffusivity is calculated by the
<em>ab initio</em> data.</p>
<p>In this case, <span class="math inline">\(k_{\text{eff}} =
\frac{|q|}{|T_{\text{left}} - T_{\text{right}}|/L} =
48.268\,\mathrm{W/mK}\)</span> (34.56% of bulk). And it can be seen that
Fourier's law propagates heat way too fast.</p>
<h2 id="l10mathrmmu-m-almost-fourier"><span
class="math inline">\(L=10\,\mathrm{\mu m}\)</span>: almost Fourier</h2>
<img src="/images/2023/MC-silicon-film/10um.png" class="" width="400" title="10 um">
<p>Here <span class="math inline">\(k_{\text{eff}} =
119.370\,\mathrm{W/mK}\)</span> (85.58% of bulk). Thermal diffusion
predicted by Fourier's law is still faster, but not that much.</p>
<h2 id="l100mathrmmu-m-fourier"><span
class="math inline">\(L=100\,\mathrm{\mu m}\)</span>: Fourier</h2>
<img src="/images/2023/MC-silicon-film/100um.png" class="" width="400" title="100 um">
<p>Here <span class="math inline">\(k_{\text{eff}} =
k_{\text{bulk}}\)</span>. Fourier's law is fully recovered.</p>
<h2 id="effective-thermal-conductivity-vs.-film-thickness">Effective
thermal conductivity vs. film thickness</h2>
<p>Here I compare the effective thermal conductivity calculated by the
present VRMC and the results reported by Jeong et al. using MD.</p>
<p>The results are remarkably close. But notice that the predicted bulk
thermal conductivities are different by 10%. Anyway, it can be at least
concluded that the trend is the same.</p>
<img src="/images/2023/MC-silicon-film/thickness.png" class="" width="600" title="k vs. L">
<h1 id="references">References</h1>
<ol type="1">
<li>Péraud and Hadjiconstantinou, PRB 2011, <a
href="https://doi.org/10.1103/PhysRevB.84.205331">10.1103/PhysRevB.84.205331</a>.</li>
<li>Péraud and Hadjiconstantinou, APL 2012, <a
href="https://doi.org/10.1063/1.4757607">10.1063/1.4757607</a>.</li>
<li>Péraud et al., Annual Review of Heat Transfer 2014, <a
href="https://doi.org/10.1615/AnnualRevHeatTransfer.2014007381">10.1615/AnnualRevHeatTransfer.2014007381</a>.</li>
<li>1D_KMC_matlab: <a
href="https://github.com/jeanphilippeperaud/1D_KMC_matlab">https://github.com/jeanphilippeperaud/1D_KMC_matlab</a>.</li>
<li>Jeong et al., JAP 2012, <a
href="https://doi.org/10.1063/1.4710993">10.1063/1.4710993</a>.</li>
</ol>
]]></content>
      <categories>
        <category>Solid State Physics</category>
        <category>Ab Initio Calculation</category>
      </categories>
      <tags>
        <tag>Ab initio calculation</tag>
        <tag>Variance-reduced Monte Carlo</tag>
        <tag>Size effect</tag>
      </tags>
  </entry>
  <entry>
    <title>Derive phonon scattering rate from anharmonic potential</title>
    <url>/2023/10/anharmonicity/</url>
    <content><![CDATA[<h1 id="hamiltonian-of-a-crystal">Hamiltonian of a crystal</h1>
<p>Like what we did in the <a
href="/2023/10/phonon-dispersion/">previous post</a>, we would like to
do the same thing to the crystal, but in a quantum way, and also
including the anharmonic potential, i.e. the third-order term in the
Taylor expansion of the interatomic potential energy.</p>
<p>Starting from the interatomic potential, which is always expressed by
the IFCs expressed by <span
class="math inline">\(\Phi_{\alpha_1\alpha_2\dots\alpha_n}(\boldsymbol{l}_1,\boldsymbol{b}_1;\boldsymbol{l}_2,\boldsymbol{b}_2,\dots,\boldsymbol{l}_n,\boldsymbol{b}_n)\)</span>,
with <span class="math inline">\(\alpha_i\)</span> denotes direction,
<span class="math inline">\(\boldsymbol{l}_i\)</span> denotes the
lattice site, and <span class="math inline">\(\boldsymbol{b}_i\)</span>
denotes the basis atom. The interatomic potental is: <span
class="math display">\[
\begin{aligned}
    \mathcal{V} = &amp; \mathcal{V}_0 + \cancel{\mathcal{V}_1} \\
    &amp; +
\underbrace{\frac{1}{2}\sum_{\boldsymbol{l},\boldsymbol{b},\boldsymbol{l}&#39;,\boldsymbol{b}&#39;}\sum_{\alpha,\beta}
\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)u_{\alpha}(\boldsymbol{l}\boldsymbol{b})u_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)}_{\mathcal{V}_2}
+ \cdots\\
    &amp; + \underbrace{
        \frac{1}{3!}\sum_{\boldsymbol{l},\boldsymbol{b},\boldsymbol{l}&#39;,\boldsymbol{b}&#39;,\boldsymbol{l}&#39;&#39;,\boldsymbol{b}&#39;&#39;}\sum_{\alpha,\beta,\gamma}
\Phi_{\alpha,\beta,\gamma}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)u_{\alpha}(\boldsymbol{l}\boldsymbol{b})u_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)u_{\gamma}(\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)
    }_{\mathcal{V}_3} + \cdots
\end{aligned}
\]</span></p>
<p>Here, we use <span
class="math inline">\({u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})\)</span>
to note the spatial deviation of atom <span
class="math inline">\(\boldsymbol{b}\)</span> in cell <span
class="math inline">\(\boldsymbol{l}\)</span> along <span
class="math inline">\(\alpha\)</span> direction, relative to the
equilibrium position. Until here, everyone including Newton is happy, as
all we wrote is classical, and all the terms are just numbers.</p>
<p>Classical approach is useful, as it surely can depict the
oscillations in a crystal. But it is not enough to reveal the concept of
phonon, which is quantized by quantum mechanics. So we have to turn to
the quantum world, where everything is controlled by the Schrödinger
equation, and the Hamiltonian is the key to it.</p>
<div class="note default"><p>Recall the (time-independent) many-body Schrödinger equation:</p>
<p><span class="math display">\[
\hat{H} \Psi(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N) =
E \Psi(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N)
\]</span></p>
<p>where <span class="math inline">\(\hat{H} = \sum_{i=1}^N
\frac{\hat{\boldsymbol{p}}_i^2}{2m_i} +
\hat{\mathcal{V}}(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N)\)</span>
is the Hamiltonian of the system, and <span
class="math inline">\(\Psi(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N)\)</span>
is the wavefunction, <span class="math inline">\(E\)</span> is the total
energy. Generally we love the following simplification to the
wavefunction:</p>
<p><span class="math display">\[
\Psi(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N) =
\prod_{i=1}^N \psi(\boldsymbol{r}_i)
\]</span></p>
<p>that allows us to rewrite the many-body Schrödinger equation as:</p>
<p><span class="math display">\[
\hat{H}_i \psi(\boldsymbol{r}_i) = E_i \psi(\boldsymbol{r}_i),
\quad\forall i=1,2,\dots,N
\]</span></p>
<p>with <span class="math inline">\(\hat{H}_i =
\frac{\hat{\boldsymbol{p}}_i}{2 m_i} + \hat{\mathcal{V}}\)</span>.</p>
</div>
<p>Using the potential energy we wrote, the Hamiltonian of a crystal is
thus:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{H} = &amp; \sum_{\boldsymbol{l}\boldsymbol{b}} \frac{\hat{p}^2
(\boldsymbol{l}\boldsymbol{b})}{2m_{\boldsymbol{b}}}\\
    &amp; + \underbrace{\frac{1}{2}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;}
\sum_{\alpha\beta}
\Phi_{\alpha\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})
\hat{u}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)}_{\hat{V}_2}\\
    &amp; + \underbrace{\frac{1}{3!}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;}
\sum_{\alpha\beta\gamma}
\Phi_{\alpha\beta\gamma}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})
\hat{u}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\hat{u}_{\gamma}(\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)}_{\hat{\mathcal{V}}_3}
+ \dots\\
\end{aligned}
\]</span></p>
<p>Note that the deviations <span
class="math inline">\(\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})\)</span>,
the momentum <span
class="math inline">\(\hat{\boldsymbol{p}}(\boldsymbol{l}\boldsymbol{b})\)</span>
are operators rather than numbers. Their commutation relations are:</p>
<p><span class="math display">\[
[\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b}),
\hat{p}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)] =
i\hbar\delta_{\alpha\beta}\delta_{\boldsymbol{l}\boldsymbol{l}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}
\]</span></p>
<p>where <span class="math inline">\(\hat{\boldsymbol{u}}\)</span> is
the vector form of the deviation operators.</p>
<h1 id="diagonal-representation-of-the-hamiltonian">Diagonal
representation of the Hamiltonian</h1>
<h2 id="boldsymbolqboldsymbolb-representation"><span
class="math inline">\((\boldsymbol{q},\boldsymbol{b})\)</span>
representation</h2>
<p>The Hamiltonian we wrote is not diagonal, which means that the
eigenstates of the Hamiltonian are not the same as the basis we used. We
need to transform the Hamiltonian into a diagonal form, so that the
eigenstates of the Hamiltonian are the same as the basis we used.</p>
<p>Due to that we are dealing with a cyclic system, that we use periodic
boundary condition for <span class="math inline">\(N_0 = N_1\times
N_2\times N_3\)</span> unit cells, the operators <span
class="math inline">\(\hat{\boldsymbol{u}}(\boldsymbol{l}\boldsymbol{b})\)</span>
and <span
class="math inline">\(\hat{\boldsymbol{p}}(\boldsymbol{l}\boldsymbol{b})\)</span>
can be represented in the Fourier's fashion:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{\boldsymbol{u}}(\boldsymbol{l}\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{N_0}} \sum_{\boldsymbol{q}} \hat{\boldsymbol{X}}
(\boldsymbol{q};\boldsymbol{b})
\exp[i\boldsymbol{q}\cdot\boldsymbol{l}]\\
    \hat{\boldsymbol{p}}(\boldsymbol{l}\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{N_0}} \sum_{\boldsymbol{q}} \hat{\boldsymbol{P}}
(\boldsymbol{q};\boldsymbol{b})
\exp[-i\boldsymbol{q}\cdot\boldsymbol{l}]
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{q}\)</span> is the
wavevector in the first Brillouin zone. The inverse of the above
equations are:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{\boldsymbol{X}} (\boldsymbol{q};\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{N_0}} \sum_{\boldsymbol{l}}
\hat{\boldsymbol{u}}(\boldsymbol{l}\boldsymbol{b})
\exp[-i\boldsymbol{q}\cdot\boldsymbol{l}]\\
    \hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{N_0}} \sum_{\boldsymbol{l}}
\hat{\boldsymbol{p}}(\boldsymbol{l}\boldsymbol{b})
\exp[i\boldsymbol{q}\cdot\boldsymbol{l}]
\end{aligned}
\]</span></p>
<p>Note the following properties:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{\boldsymbol{X}}^\dagger (\boldsymbol{q};\boldsymbol{b}) &amp;=
\hat{\boldsymbol{X}} (-\boldsymbol{q};\boldsymbol{b})\\
    \hat{\boldsymbol{P}}^\dagger (\boldsymbol{q};\boldsymbol{b}) &amp;=
\hat{\boldsymbol{P}} (-\boldsymbol{q};\boldsymbol{b})
\end{aligned}
\]</span></p>
<div class="note primary"><p>You may ask, that why the hell we use Fourier transform to obtain
<span class="math inline">\(\hat{\boldsymbol{X}}\)</span> and inverse
Fourier transform to obtain <span
class="math inline">\(\hat{\boldsymbol{P}}\)</span>. The answer is that,
we want to keep the canonical commutation relation between those two.
Using the relation that <span
class="math inline">\([\hat{\boldsymbol{u}}(\boldsymbol{l}\boldsymbol{b}),
\hat{\boldsymbol{p}}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)] =
i\hbar\delta_{\boldsymbol{l}\boldsymbol{l}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}\)</span>,
we know that:</p>
<p><span class="math display">\[
\begin{aligned}
    \left[\hat{X}_{\alpha} (\boldsymbol{q};\boldsymbol{b}),
\hat{P}_{\beta} (\boldsymbol{q&#39;};\boldsymbol{b&#39;})\right] &amp;=
\frac{1}{N_0} \sum_{\boldsymbol{l}} \sum_{\boldsymbol{l}&#39;}
\left[\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b}),
\hat{p}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)\right]
\exp[-i(\boldsymbol{q}\cdot\boldsymbol{l}-\boldsymbol{q}&#39;\cdot\boldsymbol{l}&#39;)]
\\
    &amp;= \frac{1}{N_0} \sum_{\boldsymbol{l}}
\sum_{\boldsymbol{l}&#39;}i\hbar
\delta_{\alpha\beta}\delta_{\boldsymbol{l}\boldsymbol{l}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}\exp[-i(\boldsymbol{q}\cdot\boldsymbol{l}-\boldsymbol{q}&#39;\cdot\boldsymbol{l}&#39;)]\\
    &amp;= \frac{1}{N_0} \delta_{\alpha\beta}\sum_{\boldsymbol{l}}i\hbar
\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}\exp[-i(\boldsymbol{q}-\boldsymbol{q}&#39;)\cdot\boldsymbol{l}]\\
    &amp;= i\hbar
\delta_{\alpha\beta}\delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}
\end{aligned}
\]</span></p>
<p>Also, the reason why we multiply <span
class="math inline">\(1/\sqrt{N_0}\)</span> in the transformation is
that, we want to obtain the above canonical commutation relation.</p>
</div>
<p>With the above equations, the Hamiltonian can be rewritten as:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{1st term} &amp;= \sum_{\boldsymbol{l}\boldsymbol{b}}
\frac{\hat{p}^2 (\boldsymbol{l}\boldsymbol{b})}{2m_{\boldsymbol{b}}}\\
    &amp;= \frac{1}{N_0}\sum_{\boldsymbol{l}\boldsymbol{b}}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;} \frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}(\boldsymbol{q}&#39;;\boldsymbol{b})
\exp[-i(\boldsymbol{q}+\boldsymbol{q}&#39;)\cdot\boldsymbol{l}]\\
    &amp;= \sum_{\boldsymbol{b}}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;} \frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}(\boldsymbol{q}&#39;;\boldsymbol{b})
\delta_{\boldsymbol{0},\boldsymbol{q}+\boldsymbol{q}&#39;}\\
    &amp;=
\sum_{\boldsymbol{q}\boldsymbol{b}}\frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}^\dagger (\boldsymbol{q};\boldsymbol{b})\\
    \text{2nd term} &amp;= \frac{1}{2}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;}
\sum_{\alpha\beta}
\Phi_{\alpha\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})
\hat{u}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)\\
    &amp;= \frac{1}{2}\frac{1}{N_0}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;}
\sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;}\Phi_{\alpha\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)   \hat{X}_{\alpha}
(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\exp[i\boldsymbol{q}\cdot\boldsymbol{l} +
i\boldsymbol{q}&#39;\cdot\boldsymbol{l}&#39;]\\
    &amp;= \frac{1}{2}
\frac{1}{N_0}\sum_{\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{\boldsymbol{l}\boldsymbol{h}} \sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;}
\Phi_{\alpha\beta}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{h}\boldsymbol{b}&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\exp[i(\boldsymbol{q}+\boldsymbol{q}&#39;)\cdot\boldsymbol{l}]\exp[i\boldsymbol{q}&#39;\cdot\boldsymbol{h}]\\
    &amp;= \frac{1}{2} \sum_{\alpha\beta} \sum_{\boldsymbol{q}}
\sum_{\boldsymbol{b}\boldsymbol{b}&#39;}
\underbrace{\sum_{\boldsymbol{h}}  \Phi_{\alpha\beta}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{h}\boldsymbol{b}&#39;)
\exp[-i\boldsymbol{q}\cdot\boldsymbol{h}]}_{\equiv
\Phi_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})}
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \hat{X}_{\beta}^\dagger
(\boldsymbol{q};\boldsymbol{b}&#39;) \\
    &amp;= \frac{1}{2} \sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\Phi_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \hat{X}_{\beta}^\dagger
(\boldsymbol{q};\boldsymbol{b}&#39;)\\
    \text{3rd term} &amp;= \frac{1}{3!}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;}
\sum_{\alpha\beta\gamma}
\Phi_{\alpha\beta\gamma}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})
\hat{u}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\hat{u}_{\gamma}(\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)\\
    &amp;= \frac{1}{3!}\frac{1}{N_0^{\frac{3}{2}}}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;}
\sum_{\alpha\beta\gamma}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\exp[i\boldsymbol{q}\cdot\boldsymbol{l}+i\boldsymbol{q}&#39;\cdot\boldsymbol{l}&#39;+i\boldsymbol{q}&#39;&#39;\cdot\boldsymbol{l}&#39;&#39;]\\
    &amp;= \frac{1}{3!} \frac{1}{N_0^{\frac{3}{2}}}
\sum_{\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}\sum_{\boldsymbol{l}\boldsymbol{h}\boldsymbol{h}&#39;}
\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{h}\boldsymbol{b}&#39;;\boldsymbol{h}&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\exp[i(\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;)\cdot\boldsymbol{l}]\exp[i\boldsymbol{q}&#39;\cdot\boldsymbol{h}]\exp[i\boldsymbol{q}&#39;&#39;\cdot\boldsymbol{h}&#39;]\\
    &amp;= \frac{1}{3!} \frac{1}{\sqrt{N_0}}
\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}
\underbrace{\sum_{\boldsymbol{h}\boldsymbol{h}&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{h}\boldsymbol{b}&#39;;\boldsymbol{h}&#39;\boldsymbol{b}&#39;&#39;)
\exp[i\boldsymbol{q}&#39;\cdot\boldsymbol{h}]\exp[i\boldsymbol{q}&#39;&#39;\cdot\boldsymbol{h}&#39;]}_{\equiv
\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
}\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\delta_{\boldsymbol{G},\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}\\
    &amp;= \frac{1}{3!}
\frac{1}{\sqrt{N_0}}\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\delta_{\boldsymbol{G},\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{G}\)</span> is a
reciprocal lattice vector. Using the above derivations, the Hamiltonian
is thus expressed as,</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{H} &amp;=
\sum_{\boldsymbol{q}\boldsymbol{b}}\frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}^\dagger (\boldsymbol{q};\boldsymbol{b}) +
\frac{1}{2} \sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\Phi_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \hat{X}_{\beta}^\dagger
(\boldsymbol{q};\boldsymbol{b}&#39;) \\
    &amp;\quad + \frac{1}{3!}
\frac{1}{\sqrt{N_0}}\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\delta_{\boldsymbol{G},\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\end{aligned}
\]</span></p>
<h2 id="boldsymbolq-s-representation"><span
class="math inline">\((\boldsymbol{q}, s)\)</span> representation</h2>
<p>Now, we have just taken the first step of the Long March.</p>
<p>According to our experiences dealing with classical system (see the
<a href="/2023/10/phonon-dispersion/">previous post that solves the
classical harmonic oscillator</a>), there are <span
class="math inline">\(nd\)</span> distinct vibration modes for a crystal
with <span class="math inline">\(n\)</span> atoms in the unit cell, and
<span class="math inline">\(d\)</span> dimensions. And at the same time,
the eigenvectors that represent those modes are orthogonal to each
other. For the present case, we denote those eigenvectors as <span
class="math inline">\(\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)\)</span>,
where <span class="math inline">\(s\)</span> is phonon branch. It is
noteworthy that <span
class="math inline">\(\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)\)</span>
contains the magnitude, direction of vibration, as well as the phase of
the vibration. And it is normalized such that,</p>
<p><span class="math display">\[
\begin{aligned}
    \sum_{\boldsymbol{b}}
\boldsymbol{e}^*(\boldsymbol{b}|\boldsymbol{q}s)
\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s&#39;) &amp;=
\delta_{ss&#39;}\\
    \sum_s e_{\alpha}^*(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}s) &amp;=
\delta_{\alpha\beta}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}
\end{aligned}
\]</span></p>
<p>That is the inner product of two eigenvectors with the same
wavevector is 1 if they are the same mode, and 0 otherwise. Taken use of
this set of basis, we make another transformation:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{X}(\boldsymbol{q}s) &amp;= \sum_{\boldsymbol{b}}
\sqrt{m_{\boldsymbol{b}}}
\boldsymbol{e}^*(\boldsymbol{b}|\boldsymbol{q}s)
\hat{\boldsymbol{X}}(\boldsymbol{q};\boldsymbol{b})\\
    \hat{P}(\boldsymbol{q}s) &amp;= \sum_{\boldsymbol{b}}
\frac{1}{\sqrt{m_{\boldsymbol{b}}}}
\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)
\hat{\boldsymbol{P}}(\boldsymbol{q};\boldsymbol{b})
\end{aligned}
\]</span></p>
<div class="note primary"><p>Under this transformation, we still have the canonical commutation
relation:</p>
<p><span class="math display">\[
\begin{aligned}
    \left[\hat{X}(\boldsymbol{q}s), \hat{P}(\boldsymbol{q}&#39;s&#39;)
\right] &amp;= \sum_{\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{\alpha\beta}
\sqrt{\frac{m_{\boldsymbol{b}}}{m_{\boldsymbol{b}&#39;}}}
e^*_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}&#39;s&#39;)\left[\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}),\hat{P}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)\right]\\
    &amp;= \sum_{\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{\alpha\beta}e^*_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}&#39;s&#39;)
i\hbar
\delta_{\alpha\beta}\delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}\\
    &amp;= \sum_{\boldsymbol{b}}\sum_{\alpha}
e^*_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}&#39;s&#39;)
i\hbar \delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\\
    &amp;= i\hbar
\delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\delta_{ss&#39;}
\end{aligned}
\]</span></p>
</div>
<h2 id="annihilation-and-creation-operators">Annihilation and creation
operators</h2>
<p>Using <span class="math inline">\(\hat{X}(\boldsymbol{q}s)\)</span>
and <span class="math inline">\(\hat{P}(\boldsymbol{q}s)\)</span>, we
make the final transformation, called by the annihilation and creation
operators:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{a}_{\boldsymbol{q}s} &amp;=
\frac{1}{\sqrt{2\hbar\omega(\boldsymbol{q}s)}}\hat{P}(\boldsymbol{q}s) -
i \sqrt{\frac{\omega (\boldsymbol{q}s)}{2\hbar}} \hat{X}^\dagger
(\boldsymbol{q}s)\\
    \hat{a}^\dagger_{\boldsymbol{q}s} &amp;=
\frac{1}{\sqrt{2\hbar\omega(\boldsymbol{q}s)}}\hat{P}^\dagger(\boldsymbol{q}s)
+ i \sqrt{\frac{\omega (\boldsymbol{q}s)}{2\hbar}} \hat{X}
(\boldsymbol{q}s)
\end{aligned}
\]</span></p>
<div class="note primary"><p>You would ask, why the hell they are called annihilation and creation
operators? The answer is that, they actually annihilate or create a
phonon. To see this, I refer you to the next section.</p>
</div>
<p>where <span class="math inline">\(\omega(\boldsymbol{q}s)\)</span> is
the frequency of the phonon mode <span
class="math inline">\((\boldsymbol{q}s)\)</span>. By such definition,
using the relations that <span
class="math inline">\(\hat{X}(\boldsymbol{q}s)^\dagger =
\hat{X}(-\boldsymbol{q}s), \hat{P}(\boldsymbol{q}s)^\dagger =
\hat{P}(-\boldsymbol{q}s)\)</span>, and that <span
class="math inline">\(\omega(\boldsymbol{q}s)=\omega(-\boldsymbol{q}s)\)</span>,
the inverse transformation is:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{X}(\boldsymbol{q}s) &amp;=
-i\sqrt{\frac{\hbar}{2\omega(\boldsymbol{q}s)}}
(\hat{a}^\dagger_{\boldsymbol{q}s} - \hat{a}_{-\boldsymbol{q}s})\\
    \hat{P}(\boldsymbol{q}s) &amp;=
\sqrt{\frac{\hbar\omega(\boldsymbol{q}s)}{2}} (\hat{a}_{\boldsymbol{q}s}
+ \hat{a}_{-\boldsymbol{q}s}^\dagger)
\end{aligned}
\]</span></p>
<p>In addition, the annihilation operator and the creation operator
satisfy the following commutation relation:</p>
<p><span class="math display">\[
\begin{aligned}
    \left[\hat{a}_{\boldsymbol{q}s},\hat{a}_{\boldsymbol{q}&#39;s&#39;}^\dagger\right]
&amp;=  \frac{1}{2\hbar\sqrt{\omega(\boldsymbol{q}s)\omega(\boldsymbol{q}&#39;s&#39;)}}\left[\hat{P}(\boldsymbol{q}s),\hat{P}^\dagger(\boldsymbol{q}&#39;s&#39;)\right]
+
\frac{\sqrt{\omega(\boldsymbol{q}s)\omega(\boldsymbol{q}&#39;s&#39;)}}{2\hbar}\left[\hat{X}(\boldsymbol{q}s),\hat{X}^\dagger(\boldsymbol{q}&#39;s&#39;)\right]
\\
    &amp;\qquad - \frac{i}{2\hbar}\sqrt{\frac{\omega
(\boldsymbol{q}s)}{\omega (\boldsymbol{q}&#39;s&#39;)}}
\left[\hat{X}^\dagger(\boldsymbol{q}s),
\hat{P}^\dagger(\boldsymbol{q}&#39;s&#39;)\right] +
\frac{i}{2\hbar}\sqrt{\frac{\omega (\boldsymbol{q}&#39;s&#39;)}{\omega
(\boldsymbol{q}s)}}
\left[\hat{P}(\boldsymbol{q}s),\hat{X}(\boldsymbol{q}&#39;s&#39;)
\right]\\
    &amp;= \delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\delta_{ss&#39;}
\end{aligned}
\]</span></p>
<p>Looking back at the <span
class="math inline">\((\boldsymbol{q},\boldsymbol{b})\)</span>
representations, we have:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{\boldsymbol{X}}(\boldsymbol{q};\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{m_{\boldsymbol{b}}}}\sum_s
\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s) \hat{X}(\boldsymbol{q}s)
= -i \sum_s \sqrt{\frac{\hbar}{2 m_{\boldsymbol{b}}\omega
(\boldsymbol{q}s)}} \boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)
(\hat{a}_{\boldsymbol{q}s}^\dagger - \hat{a}_{-\boldsymbol{q}s})\\
    \hat{\boldsymbol{P}}(\boldsymbol{q};\boldsymbol{b}) &amp;=
\sqrt{m_{\boldsymbol{b}}}\sum_s
\boldsymbol{e}^*(\boldsymbol{b}|\boldsymbol{q}s)
\hat{P}(\boldsymbol{q}s) = \sum_s \sqrt{\frac{\hbar
m_{\boldsymbol{b}}\omega (\boldsymbol{q}s)}{2}}
\boldsymbol{e}^*(\boldsymbol{b}|\boldsymbol{q}s)
(\hat{a}_{\boldsymbol{q}s} + \hat{a}_{-\boldsymbol{q}s}^\dagger)
\end{aligned}
\]</span></p>
<p>The Hamiltonian can thus be rewritten as:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{1st term} &amp;=
\sum_{\boldsymbol{q}\boldsymbol{b}}\frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}^\dagger (\boldsymbol{q};\boldsymbol{b}) \\
    &amp;= \frac{1}{4}\sum_{\boldsymbol{q}\boldsymbol{b}}
\sum_{ss&#39;}\sum_{\alpha\beta} \hbar\omega (\boldsymbol{q}s)
e^*_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}(\boldsymbol{b}|\boldsymbol{q}s&#39;)
\left(\hat{a}_{\boldsymbol{q}s} +
\hat{a}_{-\boldsymbol{q}s}^\dagger\right)
\left(\hat{a}^\dagger_{\boldsymbol{q}s&#39;} +
\hat{a}_{-\boldsymbol{q}s&#39;}\right)\\
    &amp;= \frac{1}{4} \sum_{\boldsymbol{q}} \sum_{s} h\omega
(\boldsymbol{q}s) \left(\hat{a}_{\boldsymbol{q}s} +
\hat{a}_{-\boldsymbol{q}s}^\dagger\right)
\left(\hat{a}^\dagger_{\boldsymbol{q}s&#39;} +
\hat{a}_{-\boldsymbol{q}s&#39;}\right)\\
    \text{2nd term} &amp;= \frac{1}{2} \sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\Phi_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \hat{X}_{\beta}^\dagger
(\boldsymbol{q};\boldsymbol{b}&#39;) \\
    &amp;= \frac{1}{2}
\sum_{\alpha\beta}\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{ss&#39;} \Phi_{\alpha\beta}
(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\frac{\hbar}{2\sqrt{m_{\boldsymbol{b}}m_{\boldsymbol{b}&#39;}\omega
(\boldsymbol{q}s)\omega (\boldsymbol{q}s&#39;)}}
e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}^*(\boldsymbol{b}&#39;|\boldsymbol{q}s&#39;)
\left(\hat{a}_{\boldsymbol{q}s}^\dagger -
\hat{a}_{-\boldsymbol{q}s}\right) \left(\hat{a}_{\boldsymbol{q}s&#39;} -
\hat{a}^\dagger_{-\boldsymbol{q}s&#39;}\right)\\
    &amp;= \frac{1}{2}
\sum_{\alpha\beta}\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{ss&#39;} D_{\alpha\beta}^\dagger
(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\frac{\hbar}{2\sqrt{\omega (\boldsymbol{q}s)\omega
(\boldsymbol{q}s&#39;)}} e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}^*(\boldsymbol{b}&#39;|\boldsymbol{q}s&#39;)
\left(\hat{a}_{\boldsymbol{q}s}^\dagger -
\hat{a}_{-\boldsymbol{q}s}\right) \left(\hat{a}_{\boldsymbol{q}s&#39;} -
\hat{a}^\dagger_{-\boldsymbol{q}s&#39;}\right)\\
    &amp; = \frac{1}{4} \sum_{\boldsymbol{q}s} \hbar\omega
(\boldsymbol{q}s) \left(\hat{a}_{\boldsymbol{q}s}^\dagger -
\hat{a}_{-\boldsymbol{q}s}\right) \left(\hat{a}_{\boldsymbol{q}s} -
\hat{a}^\dagger_{-\boldsymbol{q}s}\right)
\end{aligned}
\]</span></p>
<p>The derivation of the 2nd term uses the fact that <span
class="math inline">\(\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)\)</span>
is the eigenvector of <span
class="math inline">\(\boldsymbol{D}(\boldsymbol{q})\)</span> (the
dynamical matrix, see <a href="/2023/10/phonon-dispersion">the previous
post</a>), and the corresponding eigenvalue is <span
class="math inline">\(\omega (\boldsymbol{q}s)^2\)</span>.</p>
<div class="note warning"><p>Above, the summation over <span class="math inline">\(s&#39;\)</span>
in the second term is cancelled due to the orthogonality of the
eigenvectors for the summation over <span
class="math inline">\(\alpha\)</span> and <span
class="math inline">\(\beta\)</span>. Specifically,</p>
<p><span class="math display">\[
\begin{aligned}
    \sum_{\boldsymbol{b}\boldsymbol{b}&#39;}\sum_{\alpha,\beta}
D_{\alpha\beta}^{\dagger}
(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q}) e_{\alpha}
(\boldsymbol{b}|\boldsymbol{q}s) e_{\beta}^*
(\boldsymbol{b}&#39;|\boldsymbol{q}s&#39;) &amp;= \omega^2
(\boldsymbol{q}s&#39;)
\sum_{\boldsymbol{b}\boldsymbol{b}&#39;}\sum_{\alpha,\beta} e_{\alpha}
(\boldsymbol{b}|\boldsymbol{q}s) e_{\beta}^*
(\boldsymbol{b}&#39;|\boldsymbol{q}s&#39;)\\
    &amp;= \omega^2 (\boldsymbol{q}s&#39;) \delta_{ss&#39;}
\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}
\end{aligned}
\]</span></p>
</div>
<p>As for the 3rd term, we have:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{3rd term} &amp;= \frac{1}{3!}
\frac{1}{\sqrt{N_0}}\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\delta_{\boldsymbol{G},\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}\\
    &amp;= \frac{1}{3!}\frac{1}{\sqrt{N_0}}
\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
i
\sqrt{\frac{\hbar^3}{8m_{\boldsymbol{b}}m_{\boldsymbol{b}&#39;}m_{\boldsymbol{b}&#39;&#39;}\omega
(\boldsymbol{q}s)\omega (\boldsymbol{q}&#39;s&#39;)\omega
(\boldsymbol{q}&#39;&#39;s&#39;&#39;)}}\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}&#39;s&#39;)
e_{\gamma}(\boldsymbol{b}&#39;&#39;|\boldsymbol{q}&#39;&#39;s&#39;&#39;)
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)\\
    &amp;=
\frac{1}{3!}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
\underbrace{\sum_{\alpha\beta\gamma\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}\frac{i}{\sqrt{N_0}}
\sqrt{\frac{\hbar^3}{8m_{\boldsymbol{b}}m_{\boldsymbol{b}&#39;}m_{\boldsymbol{b}&#39;&#39;}\omega
(\boldsymbol{q}s)\omega (\boldsymbol{q}&#39;s&#39;)\omega
(\boldsymbol{q}&#39;&#39;s&#39;&#39;)}}  \Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}&#39;s&#39;)
e_{\gamma}(\boldsymbol{b}&#39;&#39;|\boldsymbol{q}&#39;&#39;s&#39;&#39;)
}_{\equiv \Phi
(\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)}
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)\\
    &amp;=
\frac{1}{3!}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
\Phi
(\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)
\end{aligned}
\]</span></p>
<p>To summarize the results by far, we see the Hamiltonian is expressed
as:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{H} &amp;= \frac{1}{4} \sum_{\boldsymbol{q}s} \hbar\omega
(\boldsymbol{q}s) \left(\hat{a}_{\boldsymbol{q}s} +
\hat{a}_{-\boldsymbol{q}s}^\dagger\right)
\left(\hat{a}^\dagger_{\boldsymbol{q}s&#39;} +
\hat{a}_{-\boldsymbol{q}s&#39;}\right) +  \frac{1}{4}
\sum_{\boldsymbol{q}s} \hbar\omega (\boldsymbol{q}s)
\left(\hat{a}_{\boldsymbol{q}s}^\dagger -
\hat{a}_{-\boldsymbol{q}s}\right) \left(\hat{a}_{\boldsymbol{q}s} -
\hat{a}^\dagger_{-\boldsymbol{q}s}\right)\\
    &amp;\qquad +
\frac{1}{3!}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
\Phi
(\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)\\
    &amp;= \sum_{\boldsymbol{q}s} \hbar\omega (\boldsymbol{q}s)
\left(\hat{a}^\dagger_{\boldsymbol{q}s} a_{\boldsymbol{q}s} +
\frac{1}{2}\right) \\
    &amp;\qquad +
\frac{1}{3!}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
\Phi
(\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)
\end{aligned}
\]</span></p>
<h1 id="harmonic-oscillator">Harmonic oscillator</h1>
<p>Let's see what the present results can do. First, we ignore the
already-derived third-order term in the Hamiltonian, and focus on the
harmonic potential. We have:</p>
<p><span class="math display">\[
\hat{H}_{\text{harm}} = \sum_{\boldsymbol{q}s} \hbar\omega
(\boldsymbol{q}s) \left(\hat{a}^\dagger_{\boldsymbol{q}s}
\hat{a}_{\boldsymbol{q}s} + \frac{1}{2}\right)
\]</span></p>
<p>Seems to be familiar? Yes, the energy of phonons is just derived from
this equation. As well as the quantization of phonon! We recall the
many-body Schrödinger equation, say there is a state <span
class="math inline">\(\Psi\)</span>, whose energy is <span
class="math inline">\(E\)</span>, thus <span
class="math inline">\(\hat{H}_{\text{harm}}\Psi = E\Psi\)</span>. After
using the annihilator or the creation operator, we have:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{H}_{\text{harm}}(\hat{a}_{\boldsymbol{q}s}\Psi) &amp;=
\hbar\omega (\boldsymbol{q}s)  \left(\hat{a}^\dagger_{\boldsymbol{q}s}
\hat{a}_{\boldsymbol{q}s} + \frac{1}{2}\right) \hat{a}_{\boldsymbol{q}s}
\Psi = \hbar \omega(\boldsymbol{q}s)
\left(\hat{a}_{\boldsymbol{q}s}\hat{a}_{\boldsymbol{q}s}^\dagger
\hat{a}_{\boldsymbol{q}s} - \frac{1}{2}\hat{a}_{\boldsymbol{q}s}\right)
\Psi\\
    &amp;= \hat{a}_{\boldsymbol{q}s}\left(\hat{H}-\hbar\omega
(\boldsymbol{q}s)\right) \Psi = (E-\hbar\omega
(\boldsymbol{q}s))(\hat{a}_{\boldsymbol{q}s}\Psi)\\
    \hat{H}_{\text{harm}}(\hat{a}^\dagger_{\boldsymbol{q}s}\Psi) &amp;=
\hbar\omega (\boldsymbol{q}s)  \left(\hat{a}^\dagger_{\boldsymbol{q}s}
\hat{a}_{\boldsymbol{q}s} + \frac{1}{2}\right)
\hat{a}^\dagger_{\boldsymbol{q}s} \Psi = \hbar \omega(\boldsymbol{q}s)
\left(\hat{a}^\dagger_{\boldsymbol{q}s}\hat{a}_{\boldsymbol{q}s}
\hat{a}^\dagger_{\boldsymbol{q}s} +
\frac{1}{2}\hat{a}^\dagger_{\boldsymbol{q}s}\right) \Psi\\
    &amp;= \hat{a}^\dagger_{\boldsymbol{q}s}\left( \hat{H}+\hbar\omega
(\boldsymbol{q}s)\right) \Psi = (E+\hbar\omega
(\boldsymbol{q}s))(\hat{a}^\dagger_{\boldsymbol{q}s}\Psi)
\end{aligned}
\]</span></p>
<p>That is to say, through the action of the annihilation or the
creation operator, the energy of the state is changed by <span
class="math inline">\(\pm\hbar\omega (\boldsymbol{q}s)\)</span>. And the
energy of the state is quantized, that is, <span class="math inline">\(E
= \hbar\omega (\boldsymbol{q}s) n_{\boldsymbol{q}s} +
\frac{1}{2}\hbar\omega (\boldsymbol{q}s)\)</span>, where <span
class="math inline">\(n_{\boldsymbol{q}s}\)</span> is the number of
phonons in the state <span
class="math inline">\((\boldsymbol{q}s)\)</span>.</p>
<p>If we use <span
class="math inline">\(\Ket{n_{\boldsymbol{q}s}}\)</span> (normalized
eigenvector) to denote the state with <span
class="math inline">\(n_{\boldsymbol{q}s}\)</span> phonons in the state
<span class="math inline">\((\boldsymbol{q}s)\)</span>, we know
that,</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{a}_{\boldsymbol{q}s}\Ket{n_{\boldsymbol{q}s}} &amp;\propto
\Ket{n_{\boldsymbol{q}s}-1}\\
    \hat{a}^\dagger_{\boldsymbol{q}s}\Ket{n_{\boldsymbol{q}s}}
&amp;\propto \Ket{n_{\boldsymbol{q}s}+1}
\end{aligned}
\]</span></p>
<p>But the proportionality constant is not known yet. Due to Schrödinger
equation,</p>
<p><span class="math display">\[
\bra{n_{\boldsymbol{q}s}} \hat{a}_{\boldsymbol{q}s}^\dagger
\hat{a}_{\boldsymbol{q}s} \ket{n_{\boldsymbol{q}s}} =
n_{\boldsymbol{q}s} = n_{\boldsymbol{q}s}
\braket{n_{\boldsymbol{q}s}-1|n_{\boldsymbol{q}s}-1}
\]</span></p>
<p>Thus <span
class="math inline">\(\hat{a}_{\boldsymbol{q}s}\ket{n_{\boldsymbol{q}s}}
= \sqrt{n_{\boldsymbol{q}s}}\ket{n_{\boldsymbol{q}s}-1}\)</span>.
Similarly we can obtain that <span
class="math inline">\(\hat{a}^\dagger_{\boldsymbol{q}s}\ket{n_{\boldsymbol{q}s}}
= \sqrt{n_{\boldsymbol{q}s}+1}\ket{n_{\boldsymbol{q}s}+1}\)</span>.</p>
<h1 id="three-phonon-scattering">Three-phonon scattering</h1>
<p>Three-phonon scattering can be computed by the third-order term in
the Hamiltonian using Fermi's golden rule, which calculates the
transition rate between initial state <span
class="math inline">\(i\)</span> and final state <span
class="math inline">\(j\)</span> by:</p>
<p><span class="math display">\[
P_{i\rightarrow j} = \frac{2\pi}{\hbar}
\big|\bra{i}\mathcal{V}_3\ket{j}\big|^2 \delta(E_i-E_j)
\]</span></p>
<p>There are two classes of three-phonon scattering:</p>
<ul>
<li>Class 1: <span
class="math inline">\(\boldsymbol{q}+\boldsymbol{q}&#39; \rightarrow
\boldsymbol{q}&#39;&#39;\)</span></li>
<li>Class 2: <span
class="math inline">\(\boldsymbol{q}\rightarrow\boldsymbol{q}&#39; +
\boldsymbol{q}&#39;&#39;\)</span></li>
</ul>
<p>For class 1, the scattering is given by:</p>
<p><span class="math display">\[
\begin{aligned}
    P_{\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;\rightarrow
\boldsymbol{q}&#39;&#39;s&#39;&#39;} &amp;= \frac{2\pi}{\hbar}
\big|\bra{n_{\boldsymbol{q}s}-1,n_{\boldsymbol{q}&#39;s&#39;}-1,n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}+1}\mathcal{V}_3\ket{n_{\boldsymbol{q}s},n_{\boldsymbol{q}&#39;s&#39;},n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}}\big|^2\delta
(\omega(\boldsymbol{q}s)+\omega(\boldsymbol{q}&#39;s&#39;)-\omega(\boldsymbol{q}&#39;&#39;s&#39;&#39;))\\
    &amp;= \frac{2\pi}{\hbar}
\big|\Phi(-\boldsymbol{q}s,-\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)\big|^2
n_{\boldsymbol{q}s}n_{\boldsymbol{q}&#39;s&#39;}
(n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}+1)\delta
(\omega(\boldsymbol{q}s)+\omega(\boldsymbol{q}&#39;s&#39;)-\omega(\boldsymbol{q}&#39;&#39;s&#39;&#39;))
\end{aligned}
\]</span></p>
<p>The net scattering rate is:</p>
<p><span class="math display">\[
\begin{aligned}
    P_{\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;\rightarrow
\boldsymbol{q}&#39;&#39;s&#39;&#39;} -
P_{\boldsymbol{q}&#39;&#39;s&#39;&#39;,\rightarrow
\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;} &amp;= \frac{2\pi}{\hbar}
\big|\Phi(-\boldsymbol{q}s,-\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)\big|^2
\delta
(\omega(\boldsymbol{q}s)+\omega(\boldsymbol{q}&#39;s&#39;)-\omega(\boldsymbol{q}&#39;&#39;s&#39;&#39;))\\
    &amp;\quad \times
\Big[n_{\boldsymbol{q}s}n_{\boldsymbol{q}&#39;s&#39;}
(n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}+1) -
(n_{\boldsymbol{q}s}+1)(n_{\boldsymbol{q}&#39;s&#39;}+1)
n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;} \Big]
\end{aligned}
\]</span></p>
<p>Similarly, for class 2, the scattering is given by:</p>
<p><span class="math display">\[
\begin{aligned}
    P_{\boldsymbol{q}s\rightarrow
\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;} -
P_{\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;
\rightarrow \boldsymbol{q}s} &amp;= \frac{2\pi}{\hbar}
\big|\Phi(\boldsymbol{q}s,-\boldsymbol{q}&#39;s&#39;,-\boldsymbol{q}&#39;&#39;s&#39;&#39;)\big|^2
\delta
(\omega(\boldsymbol{q}s)-\omega(\boldsymbol{q}&#39;s&#39;)-\omega(\boldsymbol{q}&#39;&#39;s&#39;&#39;))\\
    &amp;\quad \times \Big[n_{\boldsymbol{q}s}
(n_{\boldsymbol{q}&#39;s&#39;}+1)
(n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}+1) -
(n_{\boldsymbol{q}s}+1)n_{\boldsymbol{q}&#39;s&#39;}n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}\Big]
\end{aligned}
\]</span></p>
<p>Yielding the net three-phonon scattering rate,</p>
<p><span class="math display">\[
\begin{aligned}
    -\left(\frac{\partial n_{\boldsymbol{q}s}}{\partial
t}\right)_{\text{scatt}} &amp;=
\sum_{\boldsymbol{q}&#39;s&#39;\boldsymbol{q}&#39;&#39;s&#39;&#39;}
\left[(P_{\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;\rightarrow
\boldsymbol{q}&#39;&#39;s&#39;&#39;} -
P_{\boldsymbol{q}&#39;&#39;s&#39;&#39;,\rightarrow
\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;})  +  \frac{1}{2}
(P_{\boldsymbol{q}s\rightarrow
\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;} -
P_{\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;
\rightarrow \boldsymbol{q}s})\right]
\end{aligned}
\]</span></p>
<p>where the factor <span class="math inline">\(\frac{1}{2}\)</span> is
to avoid double counting.</p>
<h1 id="references">References</h1>
<ol type="1">
<li>Griffiths's <em>Introduction to quantum mechanics</em>.</li>
<li>Srivastava <em>The Physics of Phonons</em>.</li>
<li>Garg's PhD thesis <em>Thermal Conductivity from First-Principles in
Bulk, Disordered, and Nanostructured Materials</em> (MIT 2011).</li>
</ol>
]]></content>
      <categories>
        <category>Solid State Physics</category>
      </categories>
      <tags>
        <tag>Phonon</tag>
        <tag>Scattering</tag>
        <tag>Interatomic force constant</tag>
        <tag>Fermi&#39;s golden rule</tag>
      </tags>
  </entry>
  <entry>
    <title>Ab initio determination of thermal conductivity of Silicon</title>
    <url>/2023/10/ab-initio/</url>
    <content><![CDATA[<h1 id="overview">Overview</h1>
<p>The <em>ab inito</em> calculation of thermal conductivity is very
complex and needs several softwares to work together. The basic idea is
to calculate the interatomic force constants (IFCs) for both the
harmonic and anharmonic terms, and then use the IFCs to calculate the
phonon dispersion relation and phonon scattering time using knowledges
that are summarized in the previous posts about <a
href="/2023/10/anharmonicity">anharmonicity</a> and <a
href="/2023/10/phonon-dispersion">phonon dispersion</a>.</p>
<h2 id="workflow">Workflow</h2>
<p>Overall, we use the following open-source softwares:</p>
<ul>
<li><a href="https://phonopy.github.io/phonopy/">phonopy</a> that helps
to generate the supercell we want.</li>
<li><a href="https://www.quantum-espresso.org/">Quantum Espresso</a>
that carries out the <em>ab initio</em> calculation of electronic
structures.</li>
<li><a
href="https://alamode.readthedocs.io/en/latest/intro.html">alamode</a>
which fits the IFCs from the <em>ab initio</em> calculation and
calculates the phonon dispersion relation and phonon scattering time and
finally thermal conductivity.</li>
</ul>
<span id="more"></span>
<p>And the whole process would be like this:</p>
<pre><code class="highlight mermaid">graph TD
    A[&quot;Construct unit cell&quot;] -- Quantum Espresso --&gt; B[&quot;Test convergence&quot;]
    A -- Quantum Espresso --&gt; B2[&quot;Solve lattice constant for zero pressure&quot;]
    A -- phonopy --&gt; C[&quot;Construct supercell&quot;]
    C -- alamode/alm/suggest --&gt; D[&quot;Figure out displace patterns&quot;]
    D -- Quantum Espresso --&gt; E[&quot;Calculate forces for each pattern&quot;]
    B -- ecutwfc, K_POINTS, conv_thr, etc. --&gt; E
    B2 -- a --&gt; E
    E -- alamode/alm/optimize --&gt; F[&quot;Fit IFCs&quot;]
    F -- alamode/anphon/phonons --&gt; H[&quot;Calculate phonon dispersion&quot;]
    F -- alamode/anphon/RTA --&gt; G[&quot;Calculate thermal conductivity&quot;]</code></pre>
<h2 id="silicon-as-an-example">Silicon as an example</h2>
<p>In this post, we will use Silicon as an example to show how to
proceed the whole workflow, as Silicon crystal is simple and well
studied.</p>
<p>Monocrystalline silicon, with diamond structure, is a face centered
cubic (fcc) lattice with two atoms in the unit cell. The lattice
constant is <span class="math inline">\(a=5.43\,\mathrm{Å}\)</span>, or
<span class="math inline">\(10.26\,\mathrm{Bohr}\)</span> (which is the
edge length of the cube shown in the following figure), and the two
atoms are located at <span class="math inline">\((0,0,0)\)</span> and
<span class="math inline">\((0.25,0.25,0.25)\)</span> in the unit
cell.</p>
<img src="/images/2023/ab-initio/Silicon-unit-cell-3D-balls.png" class="" width="300" title="Silicon unit cell">
<h1 id="construct-unit-cell">Construct unit cell</h1>
<p>The very first step is to construct a unit cell of Silicon by hand.
Using the information above, we can create a Quantum Espresso input file
<code>si.pw.in</code> with the following content for calculating the
electronic structure as well as the forces:</p>
<figure class="highlight bash"><figcaption><span>Quantum Espresso Baseline Input: si.pw.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;CONTROL</span><br><span class="line">    calculation = <span class="string">&#x27;scf&#x27;</span></span><br><span class="line">    prefix = <span class="string">&#x27;si&#x27;</span></span><br><span class="line">    pseudo_dir = <span class="string">&#x27;./pseudo/&#x27;</span></span><br><span class="line">    outdir = <span class="string">&#x27;./tmp/&#x27;</span></span><br><span class="line">    disk_io = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    verbosity = <span class="string">&#x27;high&#x27;</span></span><br><span class="line">    tprnfor = .<span class="literal">true</span>.</span><br><span class="line">    tstress = .<span class="literal">true</span>.</span><br><span class="line">/</span><br><span class="line">&amp;SYSTEM</span><br><span class="line">    ibrav = 0</span><br><span class="line">    nat = 8</span><br><span class="line">    ntyp = 1</span><br><span class="line">    ecutwfc = 40</span><br><span class="line">/</span><br><span class="line">&amp;ELECTRONS</span><br><span class="line">    conv_thr        = 1.0d-11</span><br><span class="line">    mixing_beta     = 0.7</span><br><span class="line">/</span><br><span class="line">CELL_PARAMETERS bohr</span><br><span class="line">    10.26   0.0     0.0</span><br><span class="line">    0.0     10.26   0.0</span><br><span class="line">    0.0     0.0     10.26</span><br><span class="line">ATOMIC_SPECIES</span><br><span class="line">    Si  28.0855  Si.pz-vbc.UPF</span><br><span class="line">ATOMIC_POSITIONS crystal</span><br><span class="line">    Si 0.000000000 0.000000000 0.000000000</span><br><span class="line">    Si 0.000000000 0.500000000 0.500000000</span><br><span class="line">    Si 0.500000000 0.000000000 0.500000000</span><br><span class="line">    Si 0.500000000 0.500000000 0.000000000</span><br><span class="line">    Si 0.250000000 0.250000000 0.250000000</span><br><span class="line">    Si 0.250000000 0.750000000 0.750000000</span><br><span class="line">    Si 0.750000000 0.250000000 0.750000000</span><br><span class="line">    Si 0.750000000 0.750000000 0.250000000</span><br><span class="line">K_POINTS automatic</span><br><span class="line">    4 4 4 1 1 1</span><br></pre></td></tr></table></figure>
<p>Specifications of those parameters can be found in the <a
href="https://www.quantum-espresso.org/Doc/INPUT_PW.html"><code>pw.x</code>
manual of Quantum Espresso</a>. It is worth mentioning that we let
<code>ibrav = 0</code> (free) rather than <code>ibrav = 2</code> (fcc)
because we want to further generate supercells using
<code>phonopy</code> later, and <code>phonopy</code> only supports the
case of <code>ibrav = 0</code>. The pseudo-potential file
<code>Si.pz-vbc.UPF</code> can be downloaded from <a
href="https://pseudopotentials.quantum-espresso.org/legacy_tables">Quantum
Espresso website</a>, and we take this one as it is recommended by a
senior researcher in our group. In addition, the 8 atoms in the unit
cell are inputed by hand, taking the nearest 7 neighbors of the <span
class="math inline">\((0,0,0)\)</span> atom.</p>
<p>Also to note that, the parameters <code>tprnfor</code> and
<code>tstress</code> are set to be <code>.true.</code> so that the
forces and stresses can be printed out in the output file, which is
crucial for the calculation of IFCs as well as the preliminary test of
convergence and lattice constant.</p>
<p>We can surely run a calculation by executing the following command,
generating the output file <code>si.pw.out</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Run on a single core</span></span><br><span class="line">pw.x &lt; si.pw.in &gt; si.pw.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run on 16 cores</span></span><br><span class="line">mpiexec -n 16 pw.x &lt; si.pw.in &gt; si.pw.out</span><br></pre></td></tr></table></figure>
<p>For users that use clusters with job scheduler, it is important and
recommended to evaluate the memory usage of the calculation, and it can
be done by simply running the above command for several seconds, and
then click <code>Ctrl+C</code> to terminate the calculation. In the file
<code>si.pw.out</code>, an estimated memory usage is indicated by some
lines like this:</p>
<figure class="highlight bash"><figcaption><span>si.pw.out</span></figcaption><table><tr><td class="code"><pre><span class="line">Estimated total dynamical RAM &gt;      29.03 GB</span><br></pre></td></tr></table></figure>
<h1 id="preliminary-tests-using-quantum-espresso">Preliminary tests
using Quantum Espresso</h1>
<h2 id="convergence-test">Convergence test</h2>
<p>The above baseline settings of Silicon conventional cell are actually
easy for Quantum Espresso to solve, and it takes about 1 minute to
finish the calculation on a single core. However, it is not always the
case, as we will solve very large supercell later. Therefore, now it is
the time to take advantage of the very fast speed of the baseline
calculation to test the convergence for the crucial parameters such
as:</p>
<ul>
<li><code>ecutwfc</code>: the plane wave cutoff kinetic energy (in Ry).
We change it from <span class="math inline">\(30\,\mathrm{Ry}\)</span>
to <span class="math inline">\(150\,\mathrm{Ry}\)</span>.</li>
<li><code>K_POINTS</code>: the number of <span
class="math inline">\(k\)</span> points in the Brillouin zone (in each
direction), we choose it from <span class="math inline">\(4\times
4\times 4\)</span> to <span class="math inline">\(20\times 20\times
20\)</span> (all with offsets so that it would be more accurate).</li>
<li><code>conv_thr</code>: the convergence threshold for the
self-consistent field (SCF) calculation, we change it from <span
class="math inline">\(1\times 10^{-7}\)</span> to <span
class="math inline">\(1\times 10^{-16}\)</span>.</li>
</ul>
<p>Keep in mind that, we care more about the convergence of the forces
rather than the total energy, as the forces are used to calculate the
IFCs later. Therefore, to make the forces exist, we have to manually
perturb the system a bit, say <span class="math inline">\(0.001\)</span>
crystal unit (which is about <span class="math inline">\(0.01\)</span>
Bohr), for the first Silicon atom in the cell, by modifying the
<code>ATOMIC_POSITIONS</code> block in <code>si.pw.in</code>:</p>
<figure class="highlight diff"><figcaption><span>si.pw.in</span></figcaption><table><tr><td class="code"><pre><span class="line">ATOMIC_POSITIONS crystal</span><br><span class="line"><span class="addition">+    Si 0.001000000 0.000000000 0.000000000</span></span><br><span class="line"><span class="deletion">-    Si 0.000000000 0.000000000 0.000000000</span></span><br></pre></td></tr></table></figure>
<p>To automatically perform the calculation, what I did is to write a
bash script to perform calculation from different configurations, so
that we can be free from the boring and repetitive work.</p>
<figure class="highlight bash"><figcaption><span>conv_test.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">### k conv test</span></span><br><span class="line"><span class="built_in">cp</span> si.pw.in si.pw.k.in</span><br><span class="line"><span class="keyword">for</span> k_point <span class="keyword">in</span> &#123;4..20&#125;; <span class="keyword">do</span></span><br><span class="line">    sed -i <span class="string">&quot;/K_POINTS/&#123;n;s/[0-9]\+ [0-9]\+ [0-9]\+ [0-9]\+ [0-9]\+ [0-9]\+/<span class="variable">$k_point</span> <span class="variable">$k_point</span> <span class="variable">$k_point</span> 1 1 1/&#125;&quot;</span> si.pw.k.in</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;let k_point = <span class="variable">$k_point</span>, calculating...&quot;</span></span><br><span class="line">    mpiexec -np 16 pw.x &lt; si.pw.k.in &gt; ./out/si.pw.k.<span class="variable">$k_point</span>.out</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">rm</span> si.pw.k.in</span><br><span class="line"></span><br><span class="line"><span class="comment">## Cutoff conv test</span></span><br><span class="line"><span class="built_in">cp</span> si.pw.in si.pw.ecut.in</span><br><span class="line"><span class="keyword">for</span> ((cut = <span class="number">30</span>; cut &lt;= <span class="number">150</span>; cut += <span class="number">10</span>)); <span class="keyword">do</span></span><br><span class="line">    sed -i <span class="string">&quot;s/ecutwfc = [0-9]\+/ecutwfc = <span class="variable">$cut</span>/&quot;</span> si.pw.ecut.in</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;let ecutwfc = <span class="variable">$cut</span>, calculating...&quot;</span></span><br><span class="line">    mpiexec -np 16 pw.x &lt; si.pw.ecut.in &gt; ./out/si.pw.ecut.<span class="variable">$cut</span>.out</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">rm</span> si.pw.ecut.in</span><br><span class="line"></span><br><span class="line"><span class="comment">## conv_thr test</span></span><br><span class="line"><span class="built_in">cp</span> si.pw.in si.pw.thr.in</span><br><span class="line"><span class="keyword">for</span> ((thr = <span class="number">7</span>; thr &lt;= <span class="number">16</span>; thr += <span class="number">1</span>)); <span class="keyword">do</span></span><br><span class="line">    sed -i <span class="string">&quot;s/conv_thr        = 1.0d-[0-9]\+/conv_thr        = 1.0d-<span class="variable">$thr</span>/&quot;</span> si.pw.thr.in</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;let conv_thr = 1.0d-<span class="variable">$thr</span>, calculating...&quot;</span></span><br><span class="line">    mpiexec -np 16 pw.x &lt; si.pw.thr.in &gt; ./out/si.pw.thr.<span class="variable">$thr</span>.out</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> si.pw.thr.in</span><br></pre></td></tr></table></figure>
<p>We perform the convergence test, and plot the results below. We
marked the zone in which the largest atom force is in a range within
<span class="math inline">\(10^{-6}\,\mathrm{Ry/Bohr}\)</span> comparing
to the converged result (forces are marked by purple lines). Also,
variations of the total energy are marked by dark blue lines, and the
dashed zone indicates the range within <span
class="math inline">\(10^{-3}\,\mathrm{Ry}\)</span> comparing to the
converged result.</p>
<figure>
<img src="/images/2023/ab-initio/convergence.png"
alt="Convergence test" />
<figcaption aria-hidden="true">Convergence test</figcaption>
</figure>
<p>It can be noticed that:</p>
<ul>
<li><code>ecutwfc=70</code> or larger is far enough for the
calculation.</li>
<li><code>K_POINTS</code> setting as <code>8 8 8 1 1 1</code> is enough
for the calculation of a conventional cell. For supercells, we may
reduce it to <code>4 4 4 1 1 1</code> (<span
class="math inline">\(2\times 2\times 2\)</span> supercell) or
<code>3 3 3 1 1 1</code> (<span class="math inline">\(3\times 3 \times
3\)</span> supercell), to make sure that the density of <span
class="math inline">\(k\)</span> points remains the same or becomes even
larger.</li>
<li><code>conv_thr=1.0d-11</code> is way enough.</li>
</ul>
<h2 id="lattice-constant">Lattice constant</h2>
<p>The lattice constant <span
class="math inline">\(a=10.26\,\mathrm{Bohr}\)</span> that we set
previously, may not be applicable for our problem, as it is a rough
value, and it may not be consistent with the zero-pressure condition. In
fact, the author first set <span
class="math inline">\(a=10.26\,\mathrm{Bohr}\)</span> and carried out
all the remaining calculations, and then found that the thermal
conductivity at room temperature is about <span
class="math inline">\(88\,\mathrm{W/mK}\)</span>, rather than <span
class="math inline">\(\sim 140\,\mathrm{W/mK}\)</span> that are reported
by various experiments. I then realized that the stress is about <span
class="math inline">\(-14.08\,\mathrm{GPa}\)</span>, meaning that a very
strong force is applied to strentch the solid, leading to the result
that interatomic force is weeker, and thus the thermal conductivity is
smaller.</p>
<p>To obtain a more accurate lattice constant to make sure that the
zero-pressure condition is satisfied, we write a python script to
perform a simple binary search.</p>
<figure class="highlight python"><figcaption><span>lattice_constant.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_stress</span>(<span class="params">out_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(out_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;total   stress&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            stress = line.split()[-<span class="number">1</span>]</span><br><span class="line">            stress = <span class="built_in">float</span>(stress)</span><br><span class="line">            <span class="keyword">return</span> stress</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_lattice_constant</span>(<span class="params">a, in_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(in_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;CELL_PARAMETERS&#x27;</span> <span class="keyword">in</span> lines[i]:</span><br><span class="line">            lines[i+<span class="number">1</span>] = <span class="string">&#x27;&#123;0&#125;   0.0     0.0\n&#x27;</span>.<span class="built_in">format</span>(a)</span><br><span class="line">            lines[i+<span class="number">2</span>] = <span class="string">&#x27;0.0     &#123;0&#125;   0.0\n&#x27;</span>.<span class="built_in">format</span>(a)</span><br><span class="line">            lines[i+<span class="number">3</span>] = <span class="string">&#x27;0.0     0.0     &#123;0&#125;\n&#x27;</span>.<span class="built_in">format</span>(a)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(in_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.writelines(lines)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_espresso</span>(<span class="params">in_path, out_path, np=<span class="number">8</span></span>):</span><br><span class="line">    os.system(<span class="string">&#x27;mpiexec -np &#123;0&#125; pw.x &lt; &#123;1&#125; &gt; &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(np, in_path, out_path))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a_left = <span class="number">10.00</span></span><br><span class="line">    a_right = <span class="number">10.50</span></span><br><span class="line"></span><br><span class="line">    in_path = <span class="string">&#x27;si.stress.in&#x27;</span></span><br><span class="line">    out_path = <span class="string">&#x27;si.stress.out&#x27;</span></span><br><span class="line"></span><br><span class="line">    change_lattice_constant(a_left, in_path)</span><br><span class="line">    run_espresso(in_path, out_path)</span><br><span class="line">    stress_left = read_stress(out_path)</span><br><span class="line"></span><br><span class="line">    change_lattice_constant(a_right, in_path)</span><br><span class="line">    run_espresso(in_path, out_path)</span><br><span class="line">    stress_right = read_stress(out_path)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stress_left = &#123;0&#125; GPa&#x27;</span>.<span class="built_in">format</span>(stress_left))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stress_right = &#123;0&#125; GPa&#x27;</span>.<span class="built_in">format</span>(stress_right))</span><br><span class="line"></span><br><span class="line">    threshold_lattice = <span class="number">1e-10</span></span><br><span class="line">    threshold_pressure = <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(a_left - a_right) &gt; threshold_lattice <span class="keyword">and</span> <span class="built_in">abs</span>(stress_left - stress_right) &gt; threshold_pressure:</span><br><span class="line">        a_middle = (a_left + a_right) / <span class="number">2</span></span><br><span class="line">        change_lattice_constant(a_middle, in_path)</span><br><span class="line">        run_espresso(in_path, out_path)</span><br><span class="line">        stress_middle = read_stress(out_path)</span><br><span class="line">        <span class="keyword">if</span> stress_left * stress_right &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error: stress_left * stress_right &gt; 0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> stress_middle * stress_left &lt; <span class="number">0</span>:</span><br><span class="line">            a_right = a_middle</span><br><span class="line">            stress_right = stress_middle</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a_left = a_middle</span><br><span class="line">            stress_left = stress_middle</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a_left = &#123;0&#125; Bohr, a_right = &#123;1&#125; Bohr, stress_middle = &#123;2&#125; GPa&#x27;</span>.<span class="built_in">format</span>(a_left, a_right, stress_middle))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a = &#123;0&#125; Bohr&#x27;</span>.<span class="built_in">format</span>(a_middle))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stress = &#123;0&#125; GPa&#x27;</span>.<span class="built_in">format</span>(stress_middle))</span><br></pre></td></tr></table></figure>
<p>Remember, before running the script, you have to copy the
<code>si.pw.in</code> to <code>si.stress.in</code>, and make sure that
the <code>ATOMIC_POSITIONS</code> block is changed back to the original
value without any perturbation. Also, here we'd better consistent values
of <code>ecutwfc</code>, <code>K_POINTS</code>, and
<code>conv_thr</code> with the further calculations. Here we just take
<code>70</code>, <code>8 8 8 1 1 1</code>, and <code>1.0d-11</code>,
respectively.</p>
<p>Anyway, the script will yield the result that the lattice constant is
<code>10.20753662109375 Bohr</code>, and we just take it as the new
lattice constant.</p>
<h1 id="construct-supercell-and-displace-patterns">Construct supercell
and displace patterns</h1>
<h2 id="generate-supercell-using-phonopy">Generate supercell using
<code>phonopy</code></h2>
<p>It is already quite boring to write the baseline input file for a
cell of 8 atoms, and it would be impoosible to imagine that we have to
write the input file for a cell of 64 atoms (<span
class="math inline">\(2^3\times 8\)</span>), or even 216 atoms (<span
class="math inline">\(3^3\times 8\)</span>). Fortunately,
<code>phonopy</code> provides a very convenient way to generate
supercells by one line of command. With it installed, simply run the
following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phonopy --qe -d --dim=<span class="string">&quot;2 2 2&quot;</span> -c si.pw.in</span><br></pre></td></tr></table></figure>
<p>Once again, don't forget to check if you changed
<code>si.pw.in</code> to the unperturbed settings. Also, the
<code>--dim</code> option can be whatever you want. For silicon,
<code>"2 2 2"</code> (Si222) is pretty good, but Si333 will be better if
you have the resources and time to do the calculations. Copy and paste
the contents of generated files into a new file <code>si222.pw.in</code>
and modify <code>prefix</code>, <code>nat</code>,
<code>CELL_PARAMETERS</code> and <code>K_POINTS</code>, like the
following:</p>
<figure class="highlight bash"><figcaption><span>si222.pw.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;CONTROL</span><br><span class="line">    calculation = <span class="string">&#x27;scf&#x27;</span></span><br><span class="line">    prefix = <span class="string">&#x27;si222&#x27;</span></span><br><span class="line">    pseudo_dir = <span class="string">&#x27;./pseudo/&#x27;</span></span><br><span class="line">    outdir = <span class="string">&#x27;./tmp/&#x27;</span></span><br><span class="line">    verbosity = <span class="string">&#x27;high&#x27;</span></span><br><span class="line">    tprnfor = .<span class="literal">true</span>.</span><br><span class="line">    tstress = .<span class="literal">true</span>.</span><br><span class="line">    disk_io = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">/</span><br><span class="line">&amp;SYSTEM</span><br><span class="line">    ibrav = 0</span><br><span class="line">    nat = 64</span><br><span class="line">    ntyp = 1</span><br><span class="line">    ecutwfc = 70</span><br><span class="line">/</span><br><span class="line">&amp;ELECTRONS</span><br><span class="line">    conv_thr        = 1.0d-11</span><br><span class="line">    mixing_beta     = 0.7</span><br><span class="line">/</span><br><span class="line">CELL_PARAMETERS bohr</span><br><span class="line">   20.4150732421875    0.0000000000000    0.0000000000000</span><br><span class="line">    0.0000000000000   20.4150732421875    0.0000000000000</span><br><span class="line">    0.0000000000000    0.0000000000000   20.4150732421875</span><br><span class="line">ATOMIC_SPECIES</span><br><span class="line">    Si  28.0855  Si.pz-vbc.UPF</span><br><span class="line">ATOMIC_POSITIONS crystal</span><br><span class="line">    Si   0.0000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">    Si   0.5000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">    Si   0.0000000000000000  0.5000000000000000  0.0000000000000000</span><br><span class="line">    Si   0.5000000000000000  0.5000000000000000  0.0000000000000000</span><br><span class="line">    Si   0.0000000000000000  0.0000000000000000  0.5000000000000000</span><br><span class="line">    Si   0.5000000000000000  0.0000000000000000  0.5000000000000000</span><br><span class="line">    Si   0.0000000000000000  0.5000000000000000  0.5000000000000000</span><br><span class="line">    Si   0.5000000000000000  0.5000000000000000  0.5000000000000000</span><br><span class="line">    Si   0.0000000000000000  0.2500000000000000  0.2500000000000000</span><br><span class="line">    Si   0.5000000000000000  0.2500000000000000  0.2500000000000000</span><br><span class="line">    Si   0.0000000000000000  0.7500000000000000  0.2500000000000000</span><br><span class="line">    Si   0.5000000000000000  0.7500000000000000  0.2500000000000000</span><br><span class="line">    Si   0.0000000000000000  0.2500000000000000  0.7500000000000000</span><br><span class="line">    Si   0.5000000000000000  0.2500000000000000  0.7500000000000000</span><br><span class="line">    Si   0.0000000000000000  0.7500000000000000  0.7500000000000000</span><br><span class="line">    Si   0.5000000000000000  0.7500000000000000  0.7500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.0000000000000000  0.2500000000000000</span><br><span class="line">    Si   0.7500000000000000  0.0000000000000000  0.2500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.5000000000000000  0.2500000000000000</span><br><span class="line">    Si   0.7500000000000000  0.5000000000000000  0.2500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.0000000000000000  0.7500000000000000</span><br><span class="line">    Si   0.7500000000000000  0.0000000000000000  0.7500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.5000000000000000  0.7500000000000000</span><br><span class="line">    Si   0.7500000000000000  0.5000000000000000  0.7500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.2500000000000000  0.0000000000000000</span><br><span class="line">    Si   0.7500000000000000  0.2500000000000000  0.0000000000000000</span><br><span class="line">    Si   0.2500000000000000  0.7500000000000000  0.0000000000000000</span><br><span class="line">    Si   0.7500000000000000  0.7500000000000000  0.0000000000000000</span><br><span class="line">    Si   0.2500000000000000  0.2500000000000000  0.5000000000000000</span><br><span class="line">    Si   0.7500000000000000  0.2500000000000000  0.5000000000000000</span><br><span class="line">    Si   0.2500000000000000  0.7500000000000000  0.5000000000000000</span><br><span class="line">    Si   0.7500000000000000  0.7500000000000000  0.5000000000000000</span><br><span class="line">    Si   0.1250000000000000  0.1250000000000000  0.1250000000000000</span><br><span class="line">    Si   0.6250000000000000  0.1250000000000000  0.1250000000000000</span><br><span class="line">    Si   0.1250000000000000  0.6250000000000000  0.1250000000000000</span><br><span class="line">    Si   0.6250000000000000  0.6250000000000000  0.1250000000000000</span><br><span class="line">    Si   0.1250000000000000  0.1250000000000000  0.6250000000000000</span><br><span class="line">    Si   0.6250000000000000  0.1250000000000000  0.6250000000000000</span><br><span class="line">    Si   0.1250000000000000  0.6250000000000000  0.6250000000000000</span><br><span class="line">    Si   0.6250000000000000  0.6250000000000000  0.6250000000000000</span><br><span class="line">    Si   0.1250000000000000  0.3750000000000000  0.3750000000000000</span><br><span class="line">    Si   0.6250000000000000  0.3750000000000000  0.3750000000000000</span><br><span class="line">    Si   0.1250000000000000  0.8750000000000000  0.3750000000000000</span><br><span class="line">    Si   0.6250000000000000  0.8750000000000000  0.3750000000000000</span><br><span class="line">    Si   0.1250000000000000  0.3750000000000000  0.8750000000000000</span><br><span class="line">    Si   0.6250000000000000  0.3750000000000000  0.8750000000000000</span><br><span class="line">    Si   0.1250000000000000  0.8750000000000000  0.8750000000000000</span><br><span class="line">    Si   0.6250000000000000  0.8750000000000000  0.8750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.1250000000000000  0.3750000000000000</span><br><span class="line">    Si   0.8750000000000000  0.1250000000000000  0.3750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.6250000000000000  0.3750000000000000</span><br><span class="line">    Si   0.8750000000000000  0.6250000000000000  0.3750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.1250000000000000  0.8750000000000000</span><br><span class="line">    Si   0.8750000000000000  0.1250000000000000  0.8750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.6250000000000000  0.8750000000000000</span><br><span class="line">    Si   0.8750000000000000  0.6250000000000000  0.8750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.3750000000000000  0.1250000000000000</span><br><span class="line">    Si   0.8750000000000000  0.3750000000000000  0.1250000000000000</span><br><span class="line">    Si   0.3750000000000000  0.8750000000000000  0.1250000000000000</span><br><span class="line">    Si   0.8750000000000000  0.8750000000000000  0.1250000000000000</span><br><span class="line">    Si   0.3750000000000000  0.3750000000000000  0.6250000000000000</span><br><span class="line">    Si   0.8750000000000000  0.3750000000000000  0.6250000000000000</span><br><span class="line">    Si   0.3750000000000000  0.8750000000000000  0.6250000000000000</span><br><span class="line">    Si   0.8750000000000000  0.8750000000000000  0.6250000000000000</span><br><span class="line">K_POINTS automatic</span><br><span class="line">    4 4 4 1 1 1</span><br></pre></td></tr></table></figure>
<h2 id="obtain-displace-patterns">Obtain displace patterns</h2>
<p>The next step is to obtain the displace patterns for the supercell.
Create a new file <code>si222.alm.in</code> that will be used by
<code>alamode</code> to generate the patterns:</p>
<figure class="highlight bash"><figcaption><span>si222.alm.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si222</span><br><span class="line">  MODE = suggest</span><br><span class="line">  NAT = 64; NKD = 1</span><br><span class="line">  KD = Si</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;interaction</span><br><span class="line">  NORDER = 2  <span class="comment"># 1: harmonic, 2: cubic, ..</span></span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  20.4150732421875 <span class="comment"># factor in Bohr unit</span></span><br><span class="line">  1.0 0.0 0.0 <span class="comment"># a1</span></span><br><span class="line">  0.0 1.0 0.0 <span class="comment"># a2</span></span><br><span class="line">  0.0 0.0 1.0 <span class="comment"># a3</span></span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cutoff </span><br><span class="line">  Si-Si None 10.0</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;position</span><br><span class="line">  1  0.0000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">  1  0.5000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">  1  0.0000000000000000  0.5000000000000000  0.0000000000000000</span><br><span class="line">  1  0.5000000000000000  0.5000000000000000  0.0000000000000000</span><br><span class="line">  1  0.0000000000000000  0.0000000000000000  0.5000000000000000</span><br><span class="line">  1  0.5000000000000000  0.0000000000000000  0.5000000000000000</span><br><span class="line">  1  0.0000000000000000  0.5000000000000000  0.5000000000000000</span><br><span class="line">  1  0.5000000000000000  0.5000000000000000  0.5000000000000000</span><br><span class="line">  1  0.0000000000000000  0.2500000000000000  0.2500000000000000</span><br><span class="line">  1  0.5000000000000000  0.2500000000000000  0.2500000000000000</span><br><span class="line">  1  0.0000000000000000  0.7500000000000000  0.2500000000000000</span><br><span class="line">  1  0.5000000000000000  0.7500000000000000  0.2500000000000000</span><br><span class="line">  1  0.0000000000000000  0.2500000000000000  0.7500000000000000</span><br><span class="line">  1  0.5000000000000000  0.2500000000000000  0.7500000000000000</span><br><span class="line">  1  0.0000000000000000  0.7500000000000000  0.7500000000000000</span><br><span class="line">  1  0.5000000000000000  0.7500000000000000  0.7500000000000000</span><br><span class="line">  1  0.2500000000000000  0.0000000000000000  0.2500000000000000</span><br><span class="line">  1  0.7500000000000000  0.0000000000000000  0.2500000000000000</span><br><span class="line">  1  0.2500000000000000  0.5000000000000000  0.2500000000000000</span><br><span class="line">  1  0.7500000000000000  0.5000000000000000  0.2500000000000000</span><br><span class="line">  1  0.2500000000000000  0.0000000000000000  0.7500000000000000</span><br><span class="line">  1  0.7500000000000000  0.0000000000000000  0.7500000000000000</span><br><span class="line">  1  0.2500000000000000  0.5000000000000000  0.7500000000000000</span><br><span class="line">  1  0.7500000000000000  0.5000000000000000  0.7500000000000000</span><br><span class="line">  1  0.2500000000000000  0.2500000000000000  0.0000000000000000</span><br><span class="line">  1  0.7500000000000000  0.2500000000000000  0.0000000000000000</span><br><span class="line">  1  0.2500000000000000  0.7500000000000000  0.0000000000000000</span><br><span class="line">  1  0.7500000000000000  0.7500000000000000  0.0000000000000000</span><br><span class="line">  1  0.2500000000000000  0.2500000000000000  0.5000000000000000</span><br><span class="line">  1  0.7500000000000000  0.2500000000000000  0.5000000000000000</span><br><span class="line">  1  0.2500000000000000  0.7500000000000000  0.5000000000000000</span><br><span class="line">  1  0.7500000000000000  0.7500000000000000  0.5000000000000000</span><br><span class="line">  1  0.1250000000000000  0.1250000000000000  0.1250000000000000</span><br><span class="line">  1  0.6250000000000000  0.1250000000000000  0.1250000000000000</span><br><span class="line">  1  0.1250000000000000  0.6250000000000000  0.1250000000000000</span><br><span class="line">  1  0.6250000000000000  0.6250000000000000  0.1250000000000000</span><br><span class="line">  1  0.1250000000000000  0.1250000000000000  0.6250000000000000</span><br><span class="line">  1  0.6250000000000000  0.1250000000000000  0.6250000000000000</span><br><span class="line">  1  0.1250000000000000  0.6250000000000000  0.6250000000000000</span><br><span class="line">  1  0.6250000000000000  0.6250000000000000  0.6250000000000000</span><br><span class="line">  1  0.1250000000000000  0.3750000000000000  0.3750000000000000</span><br><span class="line">  1  0.6250000000000000  0.3750000000000000  0.3750000000000000</span><br><span class="line">  1  0.1250000000000000  0.8750000000000000  0.3750000000000000</span><br><span class="line">  1  0.6250000000000000  0.8750000000000000  0.3750000000000000</span><br><span class="line">  1  0.1250000000000000  0.3750000000000000  0.8750000000000000</span><br><span class="line">  1  0.6250000000000000  0.3750000000000000  0.8750000000000000</span><br><span class="line">  1  0.1250000000000000  0.8750000000000000  0.8750000000000000</span><br><span class="line">  1  0.6250000000000000  0.8750000000000000  0.8750000000000000</span><br><span class="line">  1  0.3750000000000000  0.1250000000000000  0.3750000000000000</span><br><span class="line">  1  0.8750000000000000  0.1250000000000000  0.3750000000000000</span><br><span class="line">  1  0.3750000000000000  0.6250000000000000  0.3750000000000000</span><br><span class="line">  1  0.8750000000000000  0.6250000000000000  0.3750000000000000</span><br><span class="line">  1  0.3750000000000000  0.1250000000000000  0.8750000000000000</span><br><span class="line">  1  0.8750000000000000  0.1250000000000000  0.8750000000000000</span><br><span class="line">  1  0.3750000000000000  0.6250000000000000  0.8750000000000000</span><br><span class="line">  1  0.8750000000000000  0.6250000000000000  0.8750000000000000</span><br><span class="line">  1  0.3750000000000000  0.3750000000000000  0.1250000000000000</span><br><span class="line">  1  0.8750000000000000  0.3750000000000000  0.1250000000000000</span><br><span class="line">  1  0.3750000000000000  0.8750000000000000  0.1250000000000000</span><br><span class="line">  1  0.8750000000000000  0.8750000000000000  0.1250000000000000</span><br><span class="line">  1  0.3750000000000000  0.3750000000000000  0.6250000000000000</span><br><span class="line">  1  0.8750000000000000  0.3750000000000000  0.6250000000000000</span><br><span class="line">  1  0.3750000000000000  0.8750000000000000  0.6250000000000000</span><br><span class="line">  1  0.8750000000000000  0.8750000000000000  0.6250000000000000</span><br></pre></td></tr></table></figure>
<p>Here, the mode <code>suggest</code> means that we ask
<code>alamode</code> to generate patterns. And we set the cutoff
parameters empirically. After this, execute the following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alm si222.alm.in &gt; si222.alm.log</span><br></pre></td></tr></table></figure>
<p>The harmonic and anharmonic patterns will be saved as files
<code>si222.pattern_HARMONIC</code> and
<code>si222.pattern_ANHARM3</code>, respectively. With the anharmonic
patterns (16 patterns inside the file), we perturb again the input file
of Quantum Espresso, but this time automatically by using the
<code>displace.py</code> script provided by <code>alamode</code> in its
<code>tools</code> directory.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python displace.py --QE=si222.pw.in --mag=0.01 -pf si222.pattern_ANHARM3</span><br></pre></td></tr></table></figure>
<p>The <code>--mag</code> option specifies the magnitude, and the
<code>-pf</code> option specifies the pattern file. For Si222 (and also
Si333), 16 new input files named from <code>disp01.pw.in</code> to
<code>disp16.pw.in</code> will be generated.</p>
<h1 id="calculate-forces-using-pw.x">Calculate forces using
<code>pw.x</code></h1>
<p>Just perform the calculations of all the input files generated by
<code>displace.py</code>! To be a bit lazy, I submit all the jobs using
a bash script that run through all the input files and submit them to
the queue system of the cluster in my university. It is something like
this:</p>
<figure class="highlight bash"><figcaption><span>_si.disp.submit.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    num=`<span class="built_in">echo</span> <span class="variable">$i</span> | awk <span class="string">&#x27;&#123;printf(&quot;%02d&quot;,$1)&#125;&#x27;</span>`</span><br><span class="line">    <span class="built_in">cp</span> _si.disp.sh _si.disp<span class="variable">$&#123;num&#125;</span>.sh</span><br><span class="line">    <span class="comment"># match patterns like &quot;input=disp.pw*.in&quot;, &quot;output=disp.pw*.out&quot;, change to &quot;input=disp.pw.01.in&quot;, &quot;output=disp.pw.01.out&quot;</span></span><br><span class="line">    sed -i <span class="string">&quot;s/input=disp.pw.in/input=disp<span class="variable">$&#123;num&#125;</span>.pw.in/g&quot;</span> _si.disp<span class="variable">$&#123;num&#125;</span>.sh</span><br><span class="line">    sed -i <span class="string">&quot;s/output=disp.pw.out/output=disp<span class="variable">$&#123;num&#125;</span>.pw.out/g&quot;</span> _si.disp<span class="variable">$&#123;num&#125;</span>.sh</span><br><span class="line">    qsub _si.disp<span class="variable">$&#123;num&#125;</span>.sh</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>which manipulates a submission script <code>_si.disp.sh</code>:</p>
<div class="note danger"><p>The following script is just an example, and is only suitable for the
cluster of my university. You have to modify it according to your own
cluster. Or you can simply run the calculations on your own computer
manually...</p>
</div>
<figure class="highlight bash"><figcaption><span>_si.disp.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#### submit_job.sh START ####</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#$ -cwd</span></span><br><span class="line"><span class="comment"># error = Merged with joblog</span></span><br><span class="line"><span class="comment">#$ -o joblog.$JOB_ID</span></span><br><span class="line"><span class="comment">#$ -j y</span></span><br><span class="line"><span class="comment">## Edit the line below as needed:</span></span><br><span class="line"><span class="comment">#$ -l h_rt=24:00:00,h_data=3G</span></span><br><span class="line"><span class="comment">## Modify the parallel environment</span></span><br><span class="line"><span class="comment">## and the number of cores as needed:</span></span><br><span class="line"><span class="comment">#$ -pe shared 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo job info on joblog:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> started on:   &quot;</span> `hostname -s`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> started on:   &quot;</span> `<span class="built_in">date</span> `</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load the job environment:</span></span><br><span class="line">. /u/local/Modules/default/init/modules.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">## Edit the line below as needed:</span></span><br><span class="line">module load intel/2020.4</span><br><span class="line">module load gcc/10.2.0</span><br><span class="line">module load espresso/6.7.0</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Current Packages:&quot;</span></span><br><span class="line"></span><br><span class="line">module list</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start running...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## substitute the command to run your code</span></span><br><span class="line"><span class="comment">## in the two lines below:</span></span><br><span class="line"><span class="built_in">cd</span> /PATH/TO/THE/WORKING/DIRECTORY/</span><br><span class="line"></span><br><span class="line">input=disp.pw.in</span><br><span class="line">output=disp.pw.out</span><br><span class="line"></span><br><span class="line">mpirun -np 16 pw.x &lt; <span class="variable">$&#123;input&#125;</span> &gt; <span class="variable">$&#123;output&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># try to determine if there is &quot;JOB DONE&quot; in the output file, if not, echo a warning message</span></span><br><span class="line"><span class="keyword">if</span> grep -q <span class="string">&quot;JOB DONE&quot;</span> <span class="variable">$&#123;output&#125;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;PW finished successfully&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> for <span class="variable">$input</span> ended succesffully&quot;</span> &gt;&gt; __submit_job.<span class="built_in">log</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;PW may not finished successfully&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> for <span class="variable">$input</span> FAILED!&quot;</span> &gt;&gt; __submit_job.<span class="built_in">log</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo job info on joblog:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> ended on:   &quot;</span> `hostname -s`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> ended on:   &quot;</span> `<span class="built_in">date</span> `</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="comment">#### submit_job.sh STOP ####</span></span><br></pre></td></tr></table></figure>
<p>When all the calculations are finished, we extract the forces from
the output files by using the <code>extract.py</code> script that is
also provided by <code>alamode</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python extract.py --QE=si222.pw.in ./disp*.pw.out &gt; si222.DFSET_ANHARM3</span><br></pre></td></tr></table></figure>
<h1 id="fit-ifcs-by-using-alm">Fit IFCs by using <code>alm</code></h1>
<p>Make a copy of the <code>alm</code> input file
<code>si222.alm.in</code>, name it as
<code>si222.alm.optimize.in</code>, change the following settings:</p>
<figure class="highlight diff"><figcaption><span>si222.alm.optimize.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">...</span><br><span class="line"><span class="deletion">-  MODE = suggest</span></span><br><span class="line"><span class="addition">+  MODE = optimize</span></span><br><span class="line">...</span><br><span class="line">/</span><br><span class="line"><span class="addition">+&amp;optimize</span></span><br><span class="line"><span class="addition">+  DFSET = si222.DFSET_ANHARM3</span></span><br><span class="line"><span class="addition">+/</span></span><br></pre></td></tr></table></figure>
<p>Then perfom the fitting:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alm si222.alm.optimize.in &gt; si222.alm.optimize.log</span><br></pre></td></tr></table></figure>
<p>This will generate <code>si222.xml</code>, <code>si222.fcs</code>
that are the fitted IFCs, and <code>si222.alm.optimize.log</code> that
is the log file of the fitting process.</p>
<h1 id="phonon-dispersion-relation-and-density-of-states">Phonon
dispersion relation and density of states</h1>
<p>First create a new input file for <code>anphon</code>, which is one
of the packages of <code>alamode</code>:</p>
<figure class="highlight bash"><figcaption><span>si222.phonon.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si222</span><br><span class="line">  MODE   = phonons</span><br><span class="line">  FCSXML = si222.xml</span><br><span class="line"></span><br><span class="line">  NKD = 1; KD = Si</span><br><span class="line">  MASS = 28.0855</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  10.20753662109375</span><br><span class="line">  0.0 0.5 0.5</span><br><span class="line">  0.5 0.0 0.5</span><br><span class="line">  0.5 0.5 0.0</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;kpoint</span><br><span class="line">  1  <span class="comment"># KPMODE = 1: line mode</span></span><br><span class="line">  G 0.0 0.0 0.0 X 0.5 0.5 0.0 51</span><br><span class="line">  X 0.5 0.5 1.0 G 0.0 0.0 0.0 51</span><br><span class="line">  G 0.0 0.0 0.0 L 0.5 0.5 0.5 51</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>It is worth noting that the <code>kpoint</code> field is selected to
be the line mode, meaning that anphon will calculate phonon dispersion
relation along the lines that are specified.</p>
<p>Perform the calculation by:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anphon si222.phonon.in &gt; si222.phonon.log</span><br></pre></td></tr></table></figure>
<p>Using another script <code>plotband.py</code> provided by
<code>alamode</code>, the phonon band structure can be quickly
plotted:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python plotband.py si222.bands</span><br></pre></td></tr></table></figure>
<img src="/images/2023/ab-initio/band.png" class="" width="500" title="Phonon band structure">
<p>As for the density of states, just change the <code>kpoint</code>
field to:</p>
<figure class="highlight diff"><figcaption><span>si222.phonon.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;kpoint</span><br><span class="line"><span class="deletion">-  1  # KPMODE = 1: line mode</span></span><br><span class="line"><span class="deletion">-  G 0.0 0.0 0.0 X 0.5 0.5 0.0 51</span></span><br><span class="line"><span class="deletion">-  X 0.5 0.5 1.0 G 0.0 0.0 0.0 51</span></span><br><span class="line"><span class="deletion">-  G 0.0 0.0 0.0 L 0.5 0.5 0.5 51</span></span><br><span class="line"><span class="addition">+  2</span></span><br><span class="line"><span class="addition">+  20 20 20</span></span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>perform the same command again, <code>anphon</code> will create
<code>si222.dos</code> and <code>si.thermo</code> that are the density
of states and the thermodynamic properties. To see the DoS, just use
<code>plotdos.py</code>, with the following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python plotdos.py --emax 550 --nokey si222.dos</span><br></pre></td></tr></table></figure>
<img src="/images/2023/ab-initio/dos.png" class="" width="500" title="Density of states">
<h1 id="calculate-thermal-conductivity">Calculate thermal
conductivity</h1>
<p>Now it is time to calculate the thermal conductivity. We still use
<code>anphon</code>, and let's create a config file
<code>si222.RTA.in</code> similar to the one of phonon dispersion
relation:</p>
<figure class="highlight bash"><figcaption><span>si222.RTA.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si222</span><br><span class="line">  MODE   = RTA</span><br><span class="line">  FCSXML = si222.xml</span><br><span class="line"></span><br><span class="line">  NKD = 1; KD = Si</span><br><span class="line">  MASS = 28.0855</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  10.20753662109375</span><br><span class="line">  0.0 0.5 0.5</span><br><span class="line">  0.5 0.0 0.5</span><br><span class="line">  0.5 0.5 0.0</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;kpoint</span><br><span class="line">  2</span><br><span class="line">  20 20 20</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>where <code>mode=RTA</code> means that we are going to use
relaxation-time approximation (RTA) to calculate the thermal
conductivity. The <code>FCSXML</code> option specifies the IFCs file
that we just obtained. The <code>cell</code> block, as you can see,
specifies a primitive cell of Silicon monocrystalline, and it is surely
different than the supercell that we used above. The <code>kpoint</code>
block specifies the number of wavevectors in each direction of the
reciprocal space, and it can be set to quite large comparing with that
of the supercell.</p>
<p>Perform the calculation by:</p>
<div class="note primary"><p>Although the official documentation of <code>alamode</code> claims
that <code>anphon</code> does support MPI, the parallel execution was
not working on both my computer (M1 Max Macbook Pro) and on the cluster
of my university (Intel x86). Luckily, it is not that slow to run on a
single core. Just be patient for a while.</p>
</div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anphon si222.RTA.<span class="keyword">in</span> &gt; si222.RTA.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>will give the thermal conductivity up to 1000 K, stored in
<code>si222.kl</code>, and all other information is stored in
<code>si222.result</code>. Here we plot the thermal conductivity, and
compare it with the data in literature, shown below:</p>
<img src="/images/2023/ab-initio/thermal_conductivity.png" class="" width="500" title="Thermal conductivity">
<p>If we redo all the stuff above for Si333, a nearly same result will
be obtained, and we plot the data from 250 K to 450 K, it is shown that
the difference between the calculated data for Si222 and Si333 is within
4.22 W/mK, and is about 2.5% of the value of Si222.</p>
<img src="/images/2023/ab-initio/thermal_conductivity_333.png" class="" width="500" title="Thermal conductivity comparing Si222 and Si333">
<p>It is so amazing that the calculated thermal conductivity is just in
very good agreement with the experimental data. This is the power of
physics, that we can absoultely calculate anything in the <em>ab
initio</em> way, and they just do the job!</p>
<h1 id="references">References</h1>
<ol type="1">
<li><a
href="https://alamode.readthedocs.io/en/latest/index.html">alamode
documentation</a></li>
<li><a href="https://www.quantum-espresso.org/">Quantum
Espresso</a></li>
<li><a href="https://phonopy.github.io/phonopy/">phonopy
documentation</a></li>
<li><a
href="https://icme.hpc.msstate.edu/mediawiki/index.php/How_to_make_Supercell_for_Quantum_ESPRESSO.html">How
to make Supercell for Quantum ESPRESSO</a></li>
<li><a
href="https://journals.aps.org/pr/abstract/10.1103/PhysRev.130.1743">H.
R. Shanks, P. D. Maycock, P. H. Sidles, and G. C. Danielson. Thermal
Conductivity of Silicon from 300 to 1400°K. <em>Phys. Rev.</em> 130,
1743 – Published 1 June 1963</a></li>
</ol>
]]></content>
      <categories>
        <category>Solid State Physics</category>
        <category>Ab Initio Calculation</category>
      </categories>
      <tags>
        <tag>Ab initio calculation</tag>
        <tag>Phonon</tag>
        <tag>Interatomic force constant</tag>
        <tag>Dispersion relation</tag>
        <tag>Relaxation time approximation</tag>
      </tags>
  </entry>
  <entry>
    <title>Fermi&#39;s golden rule</title>
    <url>/2023/10/golden-rule/</url>
    <content><![CDATA[<h1 id="perturbation-of-a-quantum-system">Perturbation of a quantum
system</h1>
<p>Consider a quantum system that is characterized by a Hamiltonian
<span class="math inline">\(\hat{H}_0\)</span>. Note that its
eigenstates are represented by <span
class="math inline">\(\Phi_{n}=\phi_{n}\exp(-iE_n t/\hbar),
n=1,2,\dots\)</span>, thus the time-independent Schrödinger equation is
given by</p>
<p><span class="math display">\[
\hat{H}_0\phi_{n} = E_{n}\phi_{n}
\]</span></p>
<p>Now, we perturb the system by adding a perturbation <span
class="math inline">\(\hat{\mathcal{V}}(t)\)</span>, by which the new
Hamiltonian becomes <span class="math inline">\(\hat{H} = \hat{H}_0 +
\hat{\mathcal{V}}(t)\)</span>, and we try to solve the new Schrödinger
equation. Note that those eigenstates constitute a complete set,
thus,</p>
<p><span class="math display">\[
\begin{aligned}
    \underbrace{\left( \hat{H}_0 +
\hat{\mathcal{V}}(t)\right)}_{\bar{H}} \underbrace{\sum_{j} c_{j}(t)
\Phi_{j}}_{\Phi} = i\hbar \frac{\partial}{\partial t}
\underbrace{\sum_{j} c_{j}(t) \Phi_{j}}_{\Phi}
\end{aligned}
\]</span></p>
<p>Due to that for any <span class="math inline">\(j\)</span>, <span
class="math inline">\(\hat{H}\Phi_j = i\hbar\frac{\partial}{\partial
t}\Phi_j\)</span>, the above equation can be rewritten by cancelling
stuff related with the original Hamiltonian <span
class="math inline">\(\hat{H}_0\)</span>,</p>
<p><span class="math display">\[
\hat{\mathcal{V}}(t) \sum_{j} c_j (t) \Phi_{j}= i\hbar \sum_j \Phi_{j}
\frac{\mathrm{d} c_j (t)}{\mathrm{d} t}
\]</span></p>
<p>Mathematically, for any <span class="math inline">\(f\)</span>, we
can try to multiply <span class="math inline">\(\Phi_f^*\)</span> on
both sides of the above equation, and then integrate over the whole
space, thus,</p>
<p><span class="math display">\[
\sum_{j} c_j (t) \Braket{\Phi_f | \hat{\mathcal{V}}(t) | \Phi_j} =
i\hbar \frac{\mathrm{d} c_f (t)}{\mathrm{d} t}
\]</span></p>
<p>The braket on the left side can be further expressed as,</p>
<p><span class="math display">\[
\Braket{\Phi_f | \hat{\mathcal{V}}(t) | \Phi_j} =
\underbrace{\Braket{\phi_f | \hat{\mathcal{V}}(t) | \phi_j}}_{\equiv
\mathcal{V}_{fj}} \exp\left( \frac{i(E_f - E_j)t}{\hbar} \right)
\]</span></p>
<p>Therefore, our task to study the perturbated system is then relying
on the following equations:</p>
<p><span class="math display">\[
i\hbar \frac{\mathrm{d}c_f (t)}{\mathrm{d}t} = \sum_{j} \mathcal{V}_{fj}
c_j (t) e^{\frac{i (E_f-E_j)t}{\hbar}},\quad \forall f
\]</span></p>
<p>Notice that the above equation is a set of coupled differential
equations that depict the transitions from different states <span
class="math inline">\(\phi_{n}\)</span>. It is then clear to say, if we
want to study the transition from state <span
class="math inline">\(i\)</span> to state <span
class="math inline">\(f\)</span>, we will give the initial
conditions:</p>
<p><span class="math display">\[
c_j(t)\Big|_{t=0} = \delta_{ij}
\]</span></p>
<h1
id="st-order-approximation-of-time-independent-perturbation">1st-order
approximation of time-independent perturbation</h1>
<p>We now consider a simple case where the perturbation is
time-independent, i.e., <span class="math inline">\(\hat{\mathcal{V}}(t)
= \hat{\mathcal{V}}\)</span>. Also, we only consider the transition from
state <span class="math inline">\(i\)</span> to state <span
class="math inline">\(f\)</span>, that is to set <span
class="math inline">\(c_j(t)|_{t=0}=\delta_{ij}\)</span>. The
first-order approximation of such problem is given by,</p>
<p><span class="math display">\[
i\hbar \frac{\mathrm{d}c_f (t)}{\mathrm{d}t} = \mathcal{V}_{fi}
\cancelto{1}{c_i (t)} e^{\frac{i (E_f-E_i)t}{\hbar}}
\]</span></p>
<p><span class="math display">\[
\Rightarrow c_f(t) = -\frac{\mathcal{V}_{fi}}{E_f-E_i} e^{\frac{i
(E_f-E_i)t&#39;}{\hbar}} \Big|_{t&#39;=0}^{t&#39;=t} =
-\frac{\mathcal{V}_{fi}t}{\hbar} \frac{\sin
((E_j-E_i)t/2\hbar)}{(E_j-E_i)t/2\hbar} i e^{i(E_j-E_i)t/2\hbar}
\]</span></p>
<p>The module of the final state <span class="math inline">\(f\)</span>
is then given by,</p>
<p><span class="math display">\[
\begin{aligned}
    \left|c_f (t)\right|^2 &amp;= |\mathcal{V}_{fi}|^2
\left(\frac{t}{\hbar}\frac{\sin ((E_j-E_i)t/2\hbar)}{(E_j-E_i)t/2\hbar}
\right)^2\\
    &amp;= \frac{2\pi}{\hbar} |\mathcal{V}_{fi}|^2 t
\times\delta(E_f-E_i)
\end{aligned}
\]</span></p>
<div class="note primary"><p>When we are talking about a quantum mode that has a frequency <span
class="math inline">\(\sim\omega\)</span>, the time scale should be much
larger than <span class="math inline">\(1/\omega\)</span>. It is normal
that the scale of energy difference is <span class="math inline">\(\sim
\hbar\omega\)</span>. Thus, except for the case where <span
class="math inline">\(E_f=E_i\)</span>, the term <span
class="math inline">\(\frac{(E_j-E_i)t}{2\hbar} \gg
\frac{(E_j-E_i)}{\hbar\omega}\sim 1\)</span>, making the term <span
class="math inline">\(\sin
((E_j-E_i)t/2\hbar)/((E_j-E_i)t/2\hbar)\)</span> to be either <span
class="math inline">\(1\)</span> or <span
class="math inline">\(0\)</span>. Also, for t much larger than <span
class="math inline">\(1/\omega\)</span>, with <span
class="math inline">\(|\mathcal{V}|_{fi}\)</span> the same magnitude as
<span class="math inline">\(\hbar\omega\)</span>, the whole term is then
proportional to the dirac delta function <span
class="math inline">\(\delta(E_f-E_i)\)</span>.</p>
<p>After careful examination, it is written as,</p>
<p><span class="math display">\[
\left(\frac{t}{\hbar}\frac{\sin ((E_j-E_i)t/2\hbar)}{(E_j-E_i)t/2\hbar}
\right)^2 = \frac{2\pi}{\hbar} t \times\delta(E_f-E_i)
\]</span></p>
<p>due to that <span class="math inline">\(\int_{-\infty}^{\infty} (\sin
x)^2/x^2 \mathrm{d}x = \pi\)</span>.</p>
</div>
<p>The transition rate can be read from <span class="math inline">\(|c_f
(t)|^2\)</span>:</p>
<p><span class="math display">\[
W_{fi} = \frac{2\pi}{\hbar} |\mathcal{V}_{fi}|^2 \delta(E_f-E_i)
\]</span></p>
<p>This is the very golden rule that we are looking for. It is the basis
of the derivation of the scattering rate in the <a
href="/2023/10/anharmonicity">previous post</a>, where we use the
anharmonic potential as the perturbation with respect to the harmonic
Hamiltonian.</p>
<h1 id="reference">Reference</h1>
<ol type="1">
<li>Davies, John H., Scattering Rates: the Golden Rule (A chapter from
the book <em>The Physics of Low-dimensional Semiconductors: An
Introduction</em>).</li>
<li>Griffths, David J., <em>Introduction to Quantum Mechanics</em>.</li>
</ol>
]]></content>
      <categories>
        <category>Quantum Physics</category>
      </categories>
      <tags>
        <tag>Fermi&#39;s golden rule</tag>
        <tag>Quantum physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Read ab initio data from ALAMODE output files</title>
    <url>/2023/12/read-alamode/</url>
    <content><![CDATA[<p>In order to perform a fully <em>ab initio</em> calculation, for
example, the VRMC simulation that we did in <a
href="/2023/11/MC-silicon-film">the last post</a>, <em>ab initio</em>
data, such as specific heat (spectral), phonon dispersion, and phonon
lifetime, is needed. <a
href="https://alamode.readthedocs.io/en/latest/index.html"><code>ALAMODE</code></a>
is a powerful tool to calculate these data, but the official
documentation is not very clear about the formats...</p>
<span id="more"></span>
<p>Basically, all we need is in the <code>*.result</code> file, which
contains basic information about the system, phonon frequencies,
branches, and also linewidths. But you will also need the
<code>*.self_isotope</code> file, which contains the self-energy due to
the isotope scattering (to obtain that file, please add
<code>self_isotope = 2</code> rather than <code>1</code> in the
<code>anphon</code> input file).</p>
<p>Example of these files (right click and save as):</p>
<ul>
<li><a href="/attaches/2023/si333.result">si333.result</a></li>
<li><a
href="/attaches/2023/si333.self_isotope">si333.self_isotope</a></li>
</ul>
<h1 id="contents-of-output-files">Contents of output files</h1>
<h2 id="the-.result-file">The <code>*.result</code> file</h2>
<h3 id="general-information">General information</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## General information</span><br><span class="line">#SYSTEM</span><br><span class="line">2 1</span><br><span class="line">265.904</span><br><span class="line">#END SYSTEM</span><br><span class="line">#KPOINT</span><br><span class="line">36 36 36</span><br><span class="line">1240</span><br><span class="line">     1:   0.000000e+00   0.000000e+00   0.000000e+00    0.000021</span><br><span class="line">     2:   0.000000e+00   0.000000e+00   2.777778e-02    0.000171</span><br><span class="line">     ...</span><br><span class="line">  1239:   2.222222e-01  -5.000000e-01  -2.777778e-01    0.000257</span><br><span class="line">  1240:   2.500000e-01  -5.000000e-01  -2.500000e-01    0.000129</span><br><span class="line">#END KPOINT</span><br><span class="line">#CLASSICAL</span><br><span class="line">0</span><br><span class="line">#END CLASSICAL</span><br><span class="line">#FCSXML</span><br><span class="line">si333.xml</span><br><span class="line">#END  FCSXML</span><br><span class="line">#SMEARING</span><br><span class="line">-1</span><br><span class="line">10</span><br><span class="line">#END SMEARING</span><br><span class="line">#TEMPERATURE</span><br><span class="line">200 400 20</span><br><span class="line">#END TEMPERATURE</span><br><span class="line">##END General information</span><br></pre></td></tr></table></figure>
<p>As shown above, the first section is the general information about
the system. Each subsection is separated by <code>#END</code> and
<code>#</code>. The followings are the information we need:</p>
<ul>
<li><code>#SYSTEM</code>: the second line (<code>265.904</code>) in this
subsection is the volume of the primitive cell (in Bohr<span
class="math inline">\(^3\)</span>).</li>
<li><code>#KPOINT</code>: the first line (<code>36 36 36</code>) is the
number of <span class="math inline">\(k\)</span>-points in each
direction, and their product is thus the total number of <span
class="math inline">\(k\)</span>-points. The second line
(<code>1240</code>) is the irreducible number of <span
class="math inline">\(k\)</span>-points. The following lines are thus
the coordinates of those irreducible <span
class="math inline">\(k\)</span>-points and their weights.</li>
<li><code>#TEMPERATURE</code>: The line (<code>200 400 20</code>) is the
temperature range and step size set by the <code>anphon</code> input.
For this case, their will be 11 temperatures, and the
<code>result</code> file will provide linewidths of all irreducible
modes at each temperature.</li>
</ul>
<h2 id="phonon-frequency">Phonon frequency</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##Phonon Frequency</span><br><span class="line">#K-point (irreducible), Branch, Omega (cm^-1)</span><br><span class="line">     1     1    1.09737e-10</span><br><span class="line">     1     2    1.09737e-10</span><br><span class="line">     ...</span><br><span class="line">  1240     5        461.494</span><br><span class="line">  1240     6        461.494</span><br><span class="line">##END Phonon Frequency</span><br></pre></td></tr></table></figure>
<p>This section contains frequencies of all irreducible modes. For each
line, the first number is the irreducible <span
class="math inline">\(k\)</span>-point index (from 1 to 1240), the
second number is the branch index (from 1 to 6), and the third number is
the frequency. Note that the unit is cm<span
class="math inline">\(^{-1}\)</span>, and you need to convert it to
Rad/s by multiplying <span class="math inline">\(\frac{2\pi}{c}\times
1\times 10^{2}\)</span>, where <span class="math inline">\(c\)</span> is
the speed of light in m/s.</p>
<h2 id="phonon-relaxation-time">Phonon relaxation time</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##Phonon Relaxation Time</span><br><span class="line">#GAMMA_EACH</span><br><span class="line">1 1</span><br><span class="line">1</span><br><span class="line">              0              0              0</span><br><span class="line">              0</span><br><span class="line">              0</span><br><span class="line">              ...</span><br><span class="line">       0.674943</span><br><span class="line">       0.707127</span><br><span class="line">#END GAMMA_EACH</span><br></pre></td></tr></table></figure>
<p>This section contains group velocities and linewidths of all modes at
each temperature, and it is organized by all irreducible modes.</p>
<p>In this section, there are <span class="math inline">\(n_{k,
\text{irr}}\times n_s\)</span> subsections (here is <span
class="math inline">\(1240\times 6\)</span>). Each subsection starts
with <code>#GAMMA_EACH</code> and ends with
<code>#END GAMMA_EACH</code>. Let's take a look at one of them:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#GAMMA_EACH</span><br><span class="line">13 5</span><br><span class="line">8</span><br><span class="line">       -106.711       -106.711        105.928</span><br><span class="line">       -106.711        105.928       -106.711</span><br><span class="line">        105.928        105.928        105.928</span><br><span class="line">        106.711        106.711       -105.928</span><br><span class="line">       -105.928       -105.928       -105.928</span><br><span class="line">        106.711       -105.928        106.711</span><br><span class="line">       -105.928        106.711        106.711</span><br><span class="line">        105.928       -106.711       -106.711</span><br><span class="line">        1.03999</span><br><span class="line">        1.11157</span><br><span class="line">        1.18524</span><br><span class="line">         1.2606</span><br><span class="line">        1.33733</span><br><span class="line">         1.4152</span><br><span class="line">        1.49402</span><br><span class="line">        1.57363</span><br><span class="line">        1.65393</span><br><span class="line">         1.7348</span><br><span class="line">        1.81616</span><br><span class="line">#END GAMMA_EACH</span><br></pre></td></tr></table></figure>
<p>Here, the first line (<code>13 5</code>) represents the irreducible
<span class="math inline">\(k\)</span>-point index 13 and the branch
index 5. The second line (<code>8</code>) is the number equivalent modes
of this irreducible mode. In the following 8 lines, there are 3 numbers
in each line, which are the three components of the group velocity of
that equivalent mode. After that, there are 11 lines, which are the
linewidths of that equivalent mode at each temperature.</p>
<h2 id="the-.self_isotope-file">The <code>*.self_isotope</code>
file</h2>
<p>The isotope scattering is not included in the <code>*.result</code>
file, but it is very important for the calculation of the thermal
conductivity. In the <code>*.self_isotope</code> file, there are the
self-energy due to the isotope scattering of all irreducible modes, in
the following format:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Irreducible k point  :       48 (  24)</span><br><span class="line">## xk =               0      0.0277778      -0.194444</span><br><span class="line">     48    1        84.2973     0.00050785</span><br><span class="line">     48    2        87.3591    0.000612916</span><br><span class="line">     48    3        190.352      0.0128404</span><br><span class="line">     48    4        484.132       0.411506</span><br><span class="line">     48    5         492.31      0.0912846</span><br><span class="line">     48    6        493.993      0.0783658</span><br></pre></td></tr></table></figure>
<p>in which the first line is the irreducible <span
class="math inline">\(k\)</span>-point index and the number of
equivalent modes, the second line is the coordinates of that irreducible
<span class="math inline">\(k\)</span>-point. After that, there are
<span class="math inline">\(n_s\)</span> lines, each of which contains
the irreducible <span class="math inline">\(k\)</span>-point index, the
branch index, the frequency, and the isotope scattering linewidth.</p>
<h1 id="read-data-with-python">Read data with Python</h1>
<p>Use the class <code>alamode_material</code> to read the data:</p>
<figure class="highlight python"><figcaption><span>alamode_material.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The class alamode_material is used to read the output files of ALAMODE</span></span><br><span class="line"><span class="string">to facilitate ab initio calculations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Author: Phononist (phononist@gmail.com)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">License: CC BY-NC-SA 4.0 DEED (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> constants <span class="keyword">as</span> const</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">alamode_material</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Example of use:</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; material = alamode_material(&#x27;si333.result&#x27;)</span></span><br><span class="line"><span class="string">    Or with isotope scattering:</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; material = alamode_material(&#x27;si333.result&#x27;, &#x27;si333.self_isotope&#x27;)</span></span><br><span class="line"><span class="string">    Attributes (all in SI units):</span></span><br><span class="line"><span class="string">        self.name:              str, name of the material</span></span><br><span class="line"><span class="string">        self.V_cell:            float, volume of the unit cell</span></span><br><span class="line"><span class="string">        self.k_mesh:            np.array[3], mesh of k points</span></span><br><span class="line"><span class="string">        self.nk:                int, total number of k points</span></span><br><span class="line"><span class="string">        self.nk_irr:            int, number of irreducible k points</span></span><br><span class="line"><span class="string">        self.ns:                int, number of phonon branches</span></span><br><span class="line"><span class="string">        self.k_irr:             np.array[nk_irr], irreducible k points</span></span><br><span class="line"><span class="string">        self.weight_irr:        np.array[nk_irr], weight of irreducible k points</span></span><br><span class="line"><span class="string">        self.T_array:           np.array[:], temperature array</span></span><br><span class="line"><span class="string">        self.omega:             np.array[nk_irr, ns], phonon frequency</span></span><br><span class="line"><span class="string">        self.vg:                np.array[nk, ns, 3], group velocity</span></span><br><span class="line"><span class="string">        self.full2irr:          np.array[nk], index of irreducible k points</span></span><br><span class="line"><span class="string">        self.equiv_list:        list[nk_irr] of list, equivalent k points</span></span><br><span class="line"><span class="string">        self.gamma:             np.array[nk_irr, ns, len(T_array)], self-energy (including isotope scattering)</span></span><br><span class="line"><span class="string">        self.gamma_isotope:     np.array[nk_irr, ns], self-energy from isotope scattering</span></span><br><span class="line"><span class="string">        self.scatt_time:        np.array[nk_irr, ns, len(T_array)], scattering time</span></span><br><span class="line"><span class="string">        self.cv:                np.array[nk_irr, ns, len(T_array)], spectral specific heat</span></span><br><span class="line"><span class="string">        self.cv_total:          np.array[len(T_array)], total volumetric specific heat</span></span><br><span class="line"><span class="string">        self.conductivity_xx:   np.array[len(T_array)], thermal conductivity in xx direction</span></span><br><span class="line"><span class="string">        self.conductivity_yy:   np.array[len(T_array)], thermal conductivity in yy direction</span></span><br><span class="line"><span class="string">        self.conductivity_zz:   np.array[len(T_array)], thermal conductivity in zz direction</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="string">&#x27;My Material&#x27;</span>, result_path=<span class="literal">None</span>, isotope_path=<span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.read_result(result_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Please provide the path of the result file.&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isotope_path <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.read_isotope(isotope_path)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.T_array)):</span><br><span class="line">                self.gamma[:, :, i] += self.gamma_isotope</span><br><span class="line">        self.scatt_time = np.divide(<span class="number">1</span>, <span class="number">2</span>*self.gamma, out=np.zeros_like(self.gamma), where=self.gamma!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        self.calculate_cv()</span><br><span class="line">        self.calculate_conductivity()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_result</span>(<span class="params">self, result_path</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(result_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line">        kayer_to_radpersecond = <span class="number">2</span> * const.pi * const.c * <span class="number">1e2</span></span><br><span class="line"></span><br><span class="line">        line_number = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> line_number &lt; <span class="built_in">len</span>(lines):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;#SYSTEM&#x27;</span> <span class="keyword">in</span> lines[line_number]:</span><br><span class="line">                line_number+=<span class="number">2</span></span><br><span class="line">                self.V_cell = <span class="built_in">float</span>(lines[line_number]) * const.value(<span class="string">&#x27;Bohr radius&#x27;</span>)**<span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;#KPOINT&#x27;</span> <span class="keyword">in</span> lines[line_number]:</span><br><span class="line">                line_number += <span class="number">1</span></span><br><span class="line">                self.k_mesh = np.array(lines[line_number].split(), dtype=<span class="built_in">int</span>)</span><br><span class="line">                self.nk = np.prod(self.k_mesh)</span><br><span class="line"></span><br><span class="line">                line_number += <span class="number">1</span></span><br><span class="line">                self.nk_irr = <span class="built_in">int</span>(lines[line_number])</span><br><span class="line"></span><br><span class="line">                self.k_irr = np.zeros((self.nk_irr, <span class="number">3</span>))</span><br><span class="line">                self.weight_irr = np.zeros(self.nk_irr)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.nk_irr):</span><br><span class="line">                    line_number += <span class="number">1</span></span><br><span class="line">                    self.k_irr[i, <span class="number">0</span>], self.k_irr[i, <span class="number">1</span>], self.k_irr[i, <span class="number">2</span>], self.weight_irr[i] = lines[line_number].split()[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;#TEMPERATURE&#x27;</span> <span class="keyword">in</span> lines[line_number]:</span><br><span class="line">                line_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                T_start = <span class="built_in">float</span>(lines[line_number].split()[<span class="number">0</span>])</span><br><span class="line">                T_end = <span class="built_in">float</span>(lines[line_number].split()[<span class="number">1</span>])</span><br><span class="line">                T_step = <span class="built_in">float</span>(lines[line_number].split()[<span class="number">2</span>])</span><br><span class="line">                self.T_array = np.arange(T_start, T_end + <span class="number">0.5</span>* T_step, T_step)</span><br><span class="line">                T_number = <span class="built_in">len</span>(self.T_array)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;##Phonon Frequency&#x27;</span> <span class="keyword">in</span> lines[line_number]:</span><br><span class="line">                line_number += <span class="number">2</span></span><br><span class="line">                self.ns = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">int</span>(lines[line_number + self.ns].split()[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">                    self.ns += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Allocate all parameters we need</span></span><br><span class="line">                self.omega = np.zeros((self.nk_irr, self.ns))</span><br><span class="line">                self.vg = np.zeros((self.nk, self.ns, <span class="number">3</span>))</span><br><span class="line">                vg_read_index = np.zeros(self.ns, dtype=<span class="built_in">int</span>)</span><br><span class="line">                self.full2irr = np.zeros(self.nk, dtype=<span class="built_in">int</span>)</span><br><span class="line">                self.equiv_list = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.nk_irr)]</span><br><span class="line">                self.gamma = np.zeros((self.nk_irr, self.ns, T_number))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.nk_irr*self.ns):</span><br><span class="line">                    k_i = <span class="built_in">int</span>(lines[line_number].split()[<span class="number">0</span>])</span><br><span class="line">                    s_i = <span class="built_in">int</span>(lines[line_number].split()[<span class="number">1</span>])</span><br><span class="line">                    self.omega[k_i-<span class="number">1</span>, s_i-<span class="number">1</span>] = <span class="built_in">float</span>(lines[line_number].split()[<span class="number">2</span>]) * kayer_to_radpersecond</span><br><span class="line">                    line_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;#GAMMA_EACH&#x27;</span> <span class="keyword">in</span> lines[line_number]:</span><br><span class="line">                line_number += <span class="number">1</span></span><br><span class="line">                k_i = <span class="built_in">int</span>(lines[line_number].split()[<span class="number">0</span>])</span><br><span class="line">                s_i = <span class="built_in">int</span>(lines[line_number].split()[<span class="number">1</span>])</span><br><span class="line">                line_number += <span class="number">1</span></span><br><span class="line">                equiv_number = <span class="built_in">int</span>(lines[line_number])</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(equiv_number):</span><br><span class="line">                    vg_index = vg_read_index[s_i-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> s_i == <span class="number">1</span>:</span><br><span class="line">                        self.full2irr[vg_index] = k_i-<span class="number">1</span></span><br><span class="line">                        self.equiv_list[k_i-<span class="number">1</span>].append(vg_index)</span><br><span class="line">                    </span><br><span class="line">                    line_number += <span class="number">1</span></span><br><span class="line">                    self.vg[vg_index, s_i-<span class="number">1</span>, <span class="number">0</span>], self.vg[vg_index, s_i-<span class="number">1</span>, <span class="number">1</span>], self.vg[vg_index, s_i-<span class="number">1</span>, <span class="number">2</span>] = lines[line_number].split()</span><br><span class="line">                    vg_read_index[s_i-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(T_number):</span><br><span class="line">                    line_number += <span class="number">1</span></span><br><span class="line">                    self.gamma[k_i-<span class="number">1</span>, s_i-<span class="number">1</span>, i] = <span class="built_in">float</span>(lines[line_number]) * kayer_to_radpersecond</span><br><span class="line"></span><br><span class="line">            line_number += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_isotope</span>(<span class="params">self, isotope_path</span>):</span><br><span class="line">        self.gamma_isotope = np.zeros((self.nk_irr, self.ns))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(isotope_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line">        kayer_to_radpersecond = <span class="number">2</span> * const.pi * const.c * <span class="number">1e2</span></span><br><span class="line"></span><br><span class="line">        line_number = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> line_number &lt; <span class="built_in">len</span>(lines):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;# Irreducible k point  :&#x27;</span> <span class="keyword">in</span> lines[line_number]:</span><br><span class="line">                k_i = <span class="built_in">int</span>(lines[line_number].replace(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27; &#x27;</span>).replace(<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27; &#x27;</span>).split()[-<span class="number">2</span>])</span><br><span class="line">                dos = <span class="built_in">int</span>(lines[line_number].replace(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27; &#x27;</span>).replace(<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27; &#x27;</span>).split()[-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> dos != <span class="built_in">len</span>(self.equiv_list[k_i-<span class="number">1</span>]):</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;DoS in self_isotope file is not consistent with the result file.&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    line_number += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.ns):</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">int</span>(lines[line_number].split()[<span class="number">0</span>]) != k_i <span class="keyword">or</span> <span class="built_in">int</span>(lines[line_number].split()[<span class="number">1</span>]) != i+<span class="number">1</span>:</span><br><span class="line">                            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Error in reading self_isotope file at line %d.&#x27;</span>% line_number)</span><br><span class="line">                        self.gamma_isotope[k_i-<span class="number">1</span>, i] = <span class="built_in">float</span>(lines[line_number].split()[-<span class="number">1</span>]) * kayer_to_radpersecond</span><br><span class="line">                        line_number += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            line_number += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_cv</span>(<span class="params">self</span>):</span><br><span class="line">        self.cv = np.zeros((self.nk_irr, self.ns, <span class="built_in">len</span>(self.T_array)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.T_array)):</span><br><span class="line">            <span class="keyword">if</span> self.T_array[i] &lt; <span class="number">1e-12</span>:</span><br><span class="line">                self.cv[:, :, i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span>                </span><br><span class="line">            x = const.hbar * self.omega / (const.k * self.T_array[i])</span><br><span class="line">            self.cv[:, :, i] = const.k * (x / (<span class="number">2</span> * np.sinh(x/<span class="number">2</span>)))**<span class="number">2</span> / self.V_cell</span><br><span class="line">            </span><br><span class="line">            self.cv_total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.nk_irr):</span><br><span class="line">                self.cv_total += self.cv[i, :, :].<span class="built_in">sum</span>(axis=<span class="number">0</span>) * <span class="built_in">len</span>(self.equiv_list[i]) / self.nk</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_conductivity</span>(<span class="params">self</span>):</span><br><span class="line">        self.conductivity_xx = np.zeros(<span class="built_in">len</span>(self.T_array))</span><br><span class="line">        self.conductivity_yy = np.zeros(<span class="built_in">len</span>(self.T_array))</span><br><span class="line">        self.conductivity_zz = np.zeros(<span class="built_in">len</span>(self.T_array))</span><br><span class="line">        <span class="keyword">for</span> k_i <span class="keyword">in</span> <span class="built_in">range</span>(self.nk):</span><br><span class="line">            <span class="keyword">for</span> s_i <span class="keyword">in</span> <span class="built_in">range</span>(self.ns):</span><br><span class="line">                self.conductivity_xx += <span class="number">1</span>/self.nk * self.cv[self.full2irr[k_i] ,s_i, :] * self.vg[k_i, s_i, <span class="number">0</span>]**<span class="number">2</span> * self.scatt_time[self.full2irr[k_i], s_i, :]</span><br><span class="line">                self.conductivity_yy += <span class="number">1</span>/self.nk * self.cv[self.full2irr[k_i] ,s_i, :] * self.vg[k_i, s_i, <span class="number">1</span>]**<span class="number">2</span> * self.scatt_time[self.full2irr[k_i], s_i, :]</span><br><span class="line">                self.conductivity_zz += <span class="number">1</span>/self.nk * self.cv[self.full2irr[k_i] ,s_i, :] * self.vg[k_i, s_i, <span class="number">2</span>]**<span class="number">2</span> * self.scatt_time[self.full2irr[k_i], s_i, :]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>Example of use:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> alamode_material <span class="keyword">import</span> alamode_material</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">Si = alamode_material(<span class="string">&#x27;Si&#x27;</span>, <span class="string">&#x27;si333.result&#x27;</span>, <span class="string">&#x27;si333.self_isotope&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify the specific heat and thermal conductivity values at 300K</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Volumetric specific heat at 300 K: &#123;:.2f&#125; J/(m^3 K)&quot;</span>.<span class="built_in">format</span>(Si.cv_total[np.where(Si.T_array == <span class="number">300</span>)[<span class="number">0</span>][<span class="number">0</span>]]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Thermal conductivity in xx direction at 300 K: &#123;:.2f&#125; W/(m K)&quot;</span>.<span class="built_in">format</span>(Si.conductivity_xx[np.where(Si.T_array == <span class="number">300</span>)[<span class="number">0</span>][<span class="number">0</span>]]))</span><br></pre></td></tr></table></figure>
<p>Getting the following output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Volumetric specific heat at 300 K: 1681023.27 J/(m^3 K)</span><br><span class="line">Thermal conductivity in xx direction at 300 K: 143.18 W/(m K)</span><br></pre></td></tr></table></figure>
<div class="note primary"><p>Note that the calculated thermal conductivity is slightly different
from the value given by <code>ALAMODE</code> in <code>*.kl</code> file.
I suppose that this is due to numerical errors. Luckily, the difference
is very small, for Si, it is about 0.3 W/(m K) at 300 K.</p>
</div>
]]></content>
      <categories>
        <category>Solid State Physics</category>
        <category>Ab Initio Calculation</category>
      </categories>
      <tags>
        <tag>Ab initio calculation</tag>
        <tag>Relaxation time approximation</tag>
        <tag>ALAMODE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Solve phonon dispersion relation by the classical approach</title>
    <url>/2023/10/phonon-dispersion/</url>
    <content><![CDATA[<p>Consider a crystal in which unit cells are labeled by <span
class="math inline">\(\boldsymbol{l}\)</span>, and atoms in each cell
are labeled by <span class="math inline">\(\boldsymbol{b}\)</span>. The
total energy of the system, noted by <span
class="math inline">\(\mathcal{V}\)</span>, can be expanded using
Taylor's expansion (greek letters mean direction): <span
class="math display">\[
\begin{aligned}
    \mathcal{V} = &amp; \mathcal{V}_0 +
\underbrace{\sum_{\boldsymbol{l},\boldsymbol{b}}\sum_{\alpha}
\Phi_{\alpha}(\boldsymbol{l}\boldsymbol{b})
u_{\alpha}(\boldsymbol{l}\boldsymbol{b})}_{\mathcal{V}_1} +
\underbrace{\frac{1}{2}\sum_{\boldsymbol{l},\boldsymbol{b},\boldsymbol{l}&#39;,\boldsymbol{b}&#39;}\sum_{\alpha,\beta}
\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)u_{\alpha}(\boldsymbol{l}\boldsymbol{b})u_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)}_{\mathcal{V}_2}
+ \cdots\\
    &amp; \quad +
\frac{1}{n!}\sum_{\boldsymbol{l}_1,\boldsymbol{b}_1,\boldsymbol{l}_2,\boldsymbol{b}_2,\cdots,\boldsymbol{l}_n,\boldsymbol{b}_n}\sum_{\alpha_1,\alpha_2,\cdots,\alpha_n}\Phi_{\alpha_1,\alpha_2,\cdots,\alpha_n}(\boldsymbol{l}_1,\boldsymbol{b}_1;\boldsymbol{l}_2,\boldsymbol{b}_2;\cdots;\boldsymbol{l}_n,\boldsymbol{b}_n)u_{\alpha_1}(\boldsymbol{l}_1,\boldsymbol{b}_1)\cdots
u_{\alpha_n}(\boldsymbol{l}_n \boldsymbol{b}_n)
\end{aligned}
\]</span> Where we note the nth order interatomic force constants (IFCs)
using <span class="math inline">\(\Phi\)</span>, and we note <span
class="math inline">\(u_{\alpha}(\boldsymbol{l}\boldsymbol{b})\)</span>
represent the spatial deviation of atom <span
class="math inline">\(\boldsymbol{b}\)</span> in cell <span
class="math inline">\(\boldsymbol{l}\)</span> along <span
class="math inline">\(\alpha\)</span> direction.<span id="more"></span> It is clear
to see that:</p>
<ul>
<li>The first order IFCs should be cancelled, that <span
class="math inline">\(\mathcal{V}_1=0\)</span>, due to that the system
is stable.</li>
<li>The second order term <span
class="math inline">\(\mathcal{V}_2\)</span> represent the combination
of many interatomic harmonic oscillators.</li>
</ul>
<p>Let's ignore the higher order term, keeping only <span
class="math inline">\(\mathcal{V}_2\)</span>. Using Newton's second law,
<span class="math display">\[
F_{\boldsymbol{l}\boldsymbol{b}\alpha} = m_{\boldsymbol{b}}
\ddot{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b}) =-\frac{\partial
\mathcal{V}}{\mathcal{u_{\alpha}}(\boldsymbol{l}\boldsymbol{b})}= -
\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}
\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
u_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;),\quad \forall
\boldsymbol{l},\boldsymbol{b},\alpha
\]</span> Note that the above equation exploits the symmetry of second
order IFCs, that <span
class="math inline">\(\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
=
\Phi_{\beta,\alpha}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;,\boldsymbol{l}\boldsymbol{b})\)</span>.
We now seek a solution in the form of plane waves: <span
class="math display">\[
u_{\alpha} (\boldsymbol{l}\boldsymbol{b}) =
\frac{1}{\sqrt{m_{\boldsymbol{b}}}} \sum_{\boldsymbol{q}}
U_{\alpha}(\boldsymbol{q};\boldsymbol{b})\exp \big[ i
\boldsymbol{q}\cdot \boldsymbol{l}-\omega t\big]
\]</span></p>
<div class="note info"><ul>
<li>The purpose of seaking a solution that is multiplied by <span
class="math inline">\(1/\sqrt{m_{\boldsymbol{b}}}\)</span> is just to
make the form of dynamical matrix simple and beautiful, so don't be
confused.</li>
<li>The value <span
class="math inline">\(U_{\alpha}(\boldsymbol{q};\boldsymbol{b})\)</span>
is complex. Specifically, it contains the phase information of atom
<span class="math inline">\(\boldsymbol{b}\)</span>.</li>
</ul>
</div>
<p>A specific wavevector <span
class="math inline">\(\boldsymbol{q}\)</span> yields, <span
class="math display">\[
\omega^2 \sqrt{m_{\boldsymbol{b}}}
U_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \exp
\big[i\boldsymbol{q}\cdot\boldsymbol{l}-\omega t\big] =
-\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\frac{1}{\sqrt{m_{\boldsymbol{b}&#39;}}}U_{\beta}(\boldsymbol{q};\boldsymbol{b}&#39;)\exp\big[i\boldsymbol{q}\cdot\boldsymbol{l}&#39;-\omega
t\big]
\]</span> Cancel the exponential term on both sides. Notice that due to
translational invariance, <span
class="math inline">\(\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)=\Phi_{\alpha,\beta}(\boldsymbol{0}\boldsymbol{b};(\boldsymbol{l}-\boldsymbol{l}&#39;)\boldsymbol{b}&#39;)\)</span>,
thus, <span class="math display">\[
\begin{aligned}
  \omega^2 \sqrt{m_{\boldsymbol{b}}}
U_{\alpha}(\boldsymbol{q};\boldsymbol{b}) &amp;=
-\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\frac{1}{\sqrt{m_{\boldsymbol{b}&#39;}}}U_{\beta}(\boldsymbol{q};\boldsymbol{b}&#39;)\exp\big[i\boldsymbol{q}\cdot(\boldsymbol{l}&#39;-\boldsymbol{l})\big]\\
  &amp;=
-\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}\Phi_{\alpha,\beta}(\boldsymbol{0}\boldsymbol{b};(\boldsymbol{l}&#39;-\boldsymbol{l})\boldsymbol{b}&#39;)
\frac{1}{\sqrt{m_{\boldsymbol{b}&#39;}}}U_{\beta}(\boldsymbol{q};\boldsymbol{b}&#39;)\exp\big[i\boldsymbol{q}\cdot(\boldsymbol{l}&#39;-\boldsymbol{l})\big]\\
  &amp;=
-\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}\Phi_{\alpha,\beta}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\frac{1}{\sqrt{m_{\boldsymbol{b}&#39;}}}U_{\beta}(\boldsymbol{q};\boldsymbol{b}&#39;)\exp\big[i\boldsymbol{q}\cdot\boldsymbol{l}&#39;\big]
\end{aligned}
\]</span> Therefore, if we note a matrix called "dynamical matrix", as:
<span class="math display">\[
D_{\alpha\beta} (\boldsymbol{b}\boldsymbol{b}&#39; | \boldsymbol{q}) =
\frac{1}{\sqrt{m_{\boldsymbol{b}}m_{\boldsymbol{b}&#39;}}}
\sum_{\boldsymbol{l}&#39;}
\Phi_{\alpha,\beta}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)\exp[i\boldsymbol{q}\cdot\boldsymbol{l}&#39;]
\]</span> The dynamical equations are thus in the form of matrix
multiplication, <span class="math display">\[
\omega^2 U_{\alpha} (\boldsymbol{q};\boldsymbol{b}) =
\sum_{\boldsymbol{b}&#39;,\beta}D_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
U_{\beta} (\boldsymbol{q};\boldsymbol{b}&#39;)
\]</span> Solving the above equation, we find that <span
class="math inline">\(\omega\)</span> is in fact the eigenvalue of the
dynamical matrix. Due to that <span
class="math inline">\(D_{\cdot,\cdot}(\cdot,\cdot|\boldsymbol{q})\)</span>
is a matrix of <span class="math inline">\(3p\times 3p\)</span>, where
<span class="math inline">\(p\)</span> is the number of atoms per unit
cell, and <span class="math inline">\(3\)</span> is the directions that
<span class="math inline">\(\alpha,\beta\)</span> can take, for any
given <span class="math inline">\(\boldsymbol{q}\)</span>, there are
<span class="math inline">\(3p\)</span> eigenvalues and <span
class="math inline">\(3p\)</span> eigenvectors, that correspond to
different phonon branches.</p>
<p><strong>Example: 1D diatomic chain</strong></p>
<p>Consider the 1D diatomic chain as following:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> g     g     g     g     g</span><br><span class="line">---[m]---[M]---[m]---[M]---</span><br><span class="line">     |&lt;--- a ---&gt;|</span><br></pre></td></tr></table></figure>
<p>The total energy is: <span class="math display">\[
U= \frac{1}{2}g\sum_n \left[(u_{n,1}-u_{n,2})^2 +
(u_{n,2}-u_{n+1,1})^2\right]
\]</span> where <span class="math inline">\(n\)</span> labels the unit
cell, <span class="math inline">\(1\)</span> and <span
class="math inline">\(2\)</span> represent <span
class="math inline">\(M\)</span> or <span
class="math inline">\(m\)</span>. The dynamical matrix is <span
class="math inline">\(2\times 2\)</span>, due to that there are two
atoms in each unit cell, and there is only one direction. According to
the definition, the dynamical matrix is written as, <span
class="math display">\[
D_q = \begin{bmatrix}
\frac{2g}{M} &amp; -\frac{g}{\sqrt{Mm}}(1+e^{-iqa})\\
-\frac{g}{\sqrt{Mm}}(1+e^{iqa}) &amp; \frac{2g}{m}
\end{bmatrix}
\]</span> The two eigenvalues are: <span class="math display">\[
\Rightarrow \omega^2 = g \left(\frac{1}{M} + \frac{1}{m}\right) \pm
g\sqrt{\left(\frac{1}{M} + \frac{1}{m}\right)^2-\frac{4}{Mm}
\sin^2\left(\frac{qa}{2}\right)}
\]</span> If we plot the two branches from <span
class="math inline">\(q=-\pi/a\)</span> to <span
class="math inline">\(q=\pi/a\)</span>, the dispersion relation will be
shown as:</p>
<p><img src="/images/2023/dispersion.png" alt="dispersion" style="zoom: 25%;" /></p>
]]></content>
      <categories>
        <category>Solid State Physics</category>
      </categories>
      <tags>
        <tag>Phonon</tag>
        <tag>Interatomic force constant</tag>
        <tag>Dispersion relation</tag>
        <tag>Dynamical matrix</tag>
      </tags>
  </entry>
</search>

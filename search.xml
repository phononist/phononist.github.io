<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ab initio determination of thermal conductivity of Silicon</title>
    <url>/2023/10/ab-initio/</url>
    <content><![CDATA[<h1 id="overview">Overview</h1>
<p>The <em>ab inito</em> calculation of thermal conductivity is very
complex and needs several softwares to work together. The basic idea is
to calculate the interatomic force constants (IFCs) for both the
harmonic and anharmonic terms, and then use the IFCs to calculate the
phonon dispersion relation and phonon scattering time using knowledges
that are summarized in the previous posts about <a
href="/2023/10/anharmonicity">anharmonicity</a> and <a
href="/2023/10/phonon-dispersion">phonon dispersion</a>.</p>
<h2 id="workflow">Workflow</h2>
<p>Overall, we use the following open-source softwares:</p>
<ul>
<li><a href="https://phonopy.github.io/phonopy/">phonopy</a> that helps
to generate the supercell we want.</li>
<li><a href="https://www.quantum-espresso.org/">Quantum Espresso</a>
that carries out the <em>ab initio</em> calculation of electronic
structures.</li>
<li><a
href="https://alamode.readthedocs.io/en/latest/intro.html">alamode</a>
which fits the IFCs from the <em>ab initio</em> calculation and
calculates the phonon dispersion relation and phonon scattering time and
finally thermal conductivity.</li>
</ul>
<span id="more"></span>
<p>And the whole process would be like this:</p>
<pre><code class="highlight mermaid">graph TD
    A[&quot;Construct unit cell&quot;] -- Quantum Espresso --&gt; B[&quot;Test convergence&quot;]
    A -- Quantum Espresso --&gt; B2[&quot;Solve lattice constant for zero pressure&quot;]
    A -- phonopy --&gt; C[&quot;Construct supercell&quot;]
    C -- alamode/alm/suggest --&gt; D[&quot;Figure out displace patterns&quot;]
    D -- Quantum Espresso --&gt; E[&quot;Calculate forces for each pattern&quot;]
    B -- ecutwfc, K_POINTS, conv_thr, etc. --&gt; E
    B2 -- a --&gt; E
    E -- alamode/alm/optimize --&gt; F[&quot;Fit IFCs&quot;]
    F -- alamode/anphon/phonons --&gt; H[&quot;Calculate phonon dispersion&quot;]
    F -- alamode/anphon/RTA --&gt; G[&quot;Calculate thermal conductivity&quot;]</code></pre>
<h2 id="silicon-as-an-example">Silicon as an example</h2>
<p>In this post, we will use Silicon as an example to show how to
proceed the whole workflow, as Silicon crystal is simple and well
studied.</p>
<p>Monocrystalline silicon, with diamond structure, is a face centered
cubic (fcc) lattice with two atoms in the unit cell. The lattice
constant is <span class="math inline">\(a=5.43\,\mathrm{Ã…}\)</span>, or
<span class="math inline">\(10.26\,\mathrm{Bohr}\)</span> (which is the
edge length of the cube shown in the following figure), and the two
atoms are located at <span class="math inline">\((0,0,0)\)</span> and
<span class="math inline">\((0.25,0.25,0.25)\)</span> in the unit
cell.</p>
<img src="/images/2023/ab-initio/Silicon-unit-cell-3D-balls.png" class="" width="300" title="Silicon unit cell">
<h1 id="construct-unit-cell">Construct unit cell</h1>
<p>The very first step is to construct a unit cell of Silicon by hand.
Using the information above, we can create a Quantum Espresso input file
<code>si.pw.in</code> with the following content for calculating the
electronic structure as well as the forces:</p>
<figure class="highlight bash"><figcaption><span>Quantum Espresso Baseline Input: si.pw.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;CONTROL</span><br><span class="line">    calculation = <span class="string">&#x27;scf&#x27;</span></span><br><span class="line">    prefix = <span class="string">&#x27;si&#x27;</span></span><br><span class="line">    pseudo_dir = <span class="string">&#x27;./pseudo/&#x27;</span></span><br><span class="line">    outdir = <span class="string">&#x27;./tmp/&#x27;</span></span><br><span class="line">    disk_io = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    verbosity = <span class="string">&#x27;high&#x27;</span></span><br><span class="line">    tprnfor = .<span class="literal">true</span>.</span><br><span class="line">    tstress = .<span class="literal">true</span>.</span><br><span class="line">/</span><br><span class="line">&amp;SYSTEM</span><br><span class="line">    ibrav = 0</span><br><span class="line">    nat = 8</span><br><span class="line">    ntyp = 1</span><br><span class="line">    ecutwfc = 40</span><br><span class="line">/</span><br><span class="line">&amp;ELECTRONS</span><br><span class="line">    conv_thr        = 1.0d-11</span><br><span class="line">    mixing_beta     = 0.7</span><br><span class="line">/</span><br><span class="line">CELL_PARAMETERS bohr</span><br><span class="line">    10.26   0.0     0.0</span><br><span class="line">    0.0     10.26   0.0</span><br><span class="line">    0.0     0.0     10.26</span><br><span class="line">ATOMIC_SPECIES</span><br><span class="line">    Si  28.0855  Si.pz-vbc.UPF</span><br><span class="line">ATOMIC_POSITIONS crystal</span><br><span class="line">    Si 0.000000000 0.000000000 0.000000000</span><br><span class="line">    Si 0.000000000 0.500000000 0.500000000</span><br><span class="line">    Si 0.500000000 0.000000000 0.500000000</span><br><span class="line">    Si 0.500000000 0.500000000 0.000000000</span><br><span class="line">    Si 0.250000000 0.250000000 0.250000000</span><br><span class="line">    Si 0.250000000 0.750000000 0.750000000</span><br><span class="line">    Si 0.750000000 0.250000000 0.750000000</span><br><span class="line">    Si 0.750000000 0.750000000 0.250000000</span><br><span class="line">K_POINTS automatic</span><br><span class="line">    4 4 4 1 1 1</span><br></pre></td></tr></table></figure>
<p>Specifications of those parameters can be found in the <a
href="https://www.quantum-espresso.org/Doc/INPUT_PW.html"><code>pw.x</code>
manual of Quantum Espresso</a>. It is worth mentioning that we let
<code>ibrav = 0</code> (free) rather than <code>ibrav = 2</code> (fcc)
because we want to further generate supercells using
<code>phonopy</code> later, and <code>phonopy</code> only supports the
case of <code>ibrav = 0</code>. The pseudo-potential file
<code>Si.pz-vbc.UPF</code> can be downloaded from <a
href="https://pseudopotentials.quantum-espresso.org/legacy_tables">Quantum
Espresso website</a>, and we take this one as it is recommended by a
senior researcher in our group. In addition, the 8 atoms in the unit
cell are inputed by hand, taking the nearest 7 neighbors of the <span
class="math inline">\((0,0,0)\)</span> atom.</p>
<p>Also to note that, the parameters <code>tprnfor</code> and
<code>tstress</code> are set to be <code>.true.</code> so that the
forces and stresses can be printed out in the output file, which is
crucial for the calculation of IFCs as well as the preliminary test of
convergence and lattice constant.</p>
<p>We can surely run a calculation by executing the following command,
generating the output file <code>si.pw.out</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Run on a single core</span></span><br><span class="line">pw.x &lt; si.pw.in &gt; si.pw.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run on 16 cores</span></span><br><span class="line">mpiexec -n 16 pw.x &lt; si.pw.in &gt; si.pw.out</span><br></pre></td></tr></table></figure>
<p>For users that use clusters with job scheduler, it is important and
recommended to evaluate the memory usage of the calculation, and it can
be done by simply running the above command for several seconds, and
then click <code>Ctrl+C</code> to terminate the calculation. In the file
<code>si.pw.out</code>, an estimated memory usage is indicated by some
lines like this:</p>
<figure class="highlight bash"><figcaption><span>si.pw.out</span></figcaption><table><tr><td class="code"><pre><span class="line">Estimated total dynamical RAM &gt;      29.03 GB</span><br></pre></td></tr></table></figure>
<h1 id="preliminary-tests-using-quantum-espresso">Preliminary tests
using Quantum Espresso</h1>
<h2 id="convergence-test">Convergence test</h2>
<p>The above baseline settings of Silicon conventional cell are actually
easy for Quantum Espresso to solve, and it takes about 1 minute to
finish the calculation on a single core. However, it is not always the
case, as we will solve very large supercell later. Therefore, now it is
the time to take advantage of the very fast speed of the baseline
calculation to test the convergence for the crucial parameters such
as:</p>
<ul>
<li><code>ecutwfc</code>: the plane wave cutoff kinetic energy (in Ry).
We change it from <span class="math inline">\(30\,\mathrm{Ry}\)</span>
to <span class="math inline">\(150\,\mathrm{Ry}\)</span>.</li>
<li><code>K_POINTS</code>: the number of <span
class="math inline">\(k\)</span> points in the Brillouin zone (in each
direction), we choose it from <span class="math inline">\(4\times
4\times 4\)</span> to <span class="math inline">\(20\times 20\times
20\)</span> (all with offsets so that it would be more accurate).</li>
<li><code>conv_thr</code>: the convergence threshold for the
self-consistent field (SCF) calculation, we change it from <span
class="math inline">\(1\times 10^{-7}\)</span> to <span
class="math inline">\(1\times 10^{-16}\)</span>.</li>
</ul>
<p>Keep in mind that, we care more about the convergence of the forces
rather than the total energy, as the forces are used to calculate the
IFCs later. Therefore, to make the forces exist, we have to manually
perturb the system a bit, say <span class="math inline">\(0.001\)</span>
crystal unit (which is about <span class="math inline">\(0.01\)</span>
Bohr), for the first Silicon atom in the cell, by modifying the
<code>ATOMIC_POSITIONS</code> block in <code>si.pw.in</code>:</p>
<figure class="highlight diff"><figcaption><span>si.pw.in</span></figcaption><table><tr><td class="code"><pre><span class="line">ATOMIC_POSITIONS crystal</span><br><span class="line"><span class="addition">+    Si 0.001000000 0.000000000 0.000000000</span></span><br><span class="line"><span class="deletion">-    Si 0.000000000 0.000000000 0.000000000</span></span><br></pre></td></tr></table></figure>
<p>To automatically perform the calculation, what I did is to write a
bash script to perform calculation from different configurations, so
that we can be free from the boring and repetitive work.</p>
<figure class="highlight bash"><figcaption><span>conv_test.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">### k conv test</span></span><br><span class="line"><span class="built_in">cp</span> si.pw.in si.pw.k.in</span><br><span class="line"><span class="keyword">for</span> k_point <span class="keyword">in</span> &#123;4..20&#125;; <span class="keyword">do</span></span><br><span class="line">    sed -i <span class="string">&quot;/K_POINTS/&#123;n;s/[0-9]\+ [0-9]\+ [0-9]\+ [0-9]\+ [0-9]\+ [0-9]\+/<span class="variable">$k_point</span> <span class="variable">$k_point</span> <span class="variable">$k_point</span> 1 1 1/&#125;&quot;</span> si.pw.k.in</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;let k_point = <span class="variable">$k_point</span>, calculating...&quot;</span></span><br><span class="line">    mpiexec -np 16 pw.x &lt; si.pw.k.in &gt; ./out/si.pw.k.<span class="variable">$k_point</span>.out</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">rm</span> si.pw.k.in</span><br><span class="line"></span><br><span class="line"><span class="comment">## Cutoff conv test</span></span><br><span class="line"><span class="built_in">cp</span> si.pw.in si.pw.ecut.in</span><br><span class="line"><span class="keyword">for</span> ((cut = <span class="number">30</span>; cut &lt;= <span class="number">150</span>; cut += <span class="number">10</span>)); <span class="keyword">do</span></span><br><span class="line">    sed -i <span class="string">&quot;s/ecutwfc = [0-9]\+/ecutwfc = <span class="variable">$cut</span>/&quot;</span> si.pw.ecut.in</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;let ecutwfc = <span class="variable">$cut</span>, calculating...&quot;</span></span><br><span class="line">    mpiexec -np 16 pw.x &lt; si.pw.ecut.in &gt; ./out/si.pw.ecut.<span class="variable">$cut</span>.out</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">rm</span> si.pw.ecut.in</span><br><span class="line"></span><br><span class="line"><span class="comment">## conv_thr test</span></span><br><span class="line"><span class="built_in">cp</span> si.pw.in si.pw.thr.in</span><br><span class="line"><span class="keyword">for</span> ((thr = <span class="number">7</span>; thr &lt;= <span class="number">16</span>; thr += <span class="number">1</span>)); <span class="keyword">do</span></span><br><span class="line">    sed -i <span class="string">&quot;s/conv_thr        = 1.0d-[0-9]\+/conv_thr        = 1.0d-<span class="variable">$thr</span>/&quot;</span> si.pw.thr.in</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;let conv_thr = 1.0d-<span class="variable">$thr</span>, calculating...&quot;</span></span><br><span class="line">    mpiexec -np 16 pw.x &lt; si.pw.thr.in &gt; ./out/si.pw.thr.<span class="variable">$thr</span>.out</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> si.pw.thr.in</span><br></pre></td></tr></table></figure>
<p>We perform the convergence test, and plot the results below. We
marked the zone in which the largest atom force is in a range within
<span class="math inline">\(10^{-6}\,\mathrm{Ry/Bohr}\)</span> comparing
to the converged result (forces are marked by purple lines). Also,
variations of the total energy are marked by dark blue lines, and the
dashed zone indicates the range within <span
class="math inline">\(10^{-3}\,\mathrm{Ry}\)</span> comparing to the
converged result.</p>
<figure>
<img src="/images/2023/ab-initio/convergence.png"
alt="Convergence test" />
<figcaption aria-hidden="true">Convergence test</figcaption>
</figure>
<p>It can be noticed that:</p>
<ul>
<li><code>ecutwfc=70</code> or larger is far enough for the
calculation.</li>
<li><code>K_POINTS</code> setting as <code>8 8 8 1 1 1</code> is enough
for the calculation of a conventional cell. For supercells, we may
reduce it to <code>4 4 4 1 1 1</code> (<span
class="math inline">\(2\times 2\times 2\)</span> supercell) or
<code>3 3 3 1 1 1</code> (<span class="math inline">\(3\times 3 \times
3\)</span> supercell), to make sure that the density of <span
class="math inline">\(k\)</span> points remains the same or becomes even
larger.</li>
<li><code>conv_thr=1.0d-11</code> is way enough.</li>
</ul>
<h2 id="lattice-constant">Lattice constant</h2>
<p>The lattice constant <span
class="math inline">\(a=10.26\,\mathrm{Bohr}\)</span> that we set
previously, may not be applicable for our problem, as it is a rough
value, and it may not be consistent with the zero-pressure condition. In
fact, the author first set <span
class="math inline">\(a=10.26\,\mathrm{Bohr}\)</span> and carried out
all the remaining calculations, and then found that the thermal
conductivity at room temperature is about <span
class="math inline">\(88\,\mathrm{W/mK}\)</span>, rather than <span
class="math inline">\(\sim 140\,\mathrm{W/mK}\)</span> that are reported
by various experiments. I then realized that the stress is about <span
class="math inline">\(-14.08\,\mathrm{GPa}\)</span>, meaning that a very
strong force is applied to strentch the solid, leading to the result
that interatomic force is weeker, and thus the thermal conductivity is
smaller.</p>
<p>To obtain a more accurate lattice constant to make sure that the
zero-pressure condition is satisfied, we write a python script to
perform a simple binary search.</p>
<figure class="highlight python"><figcaption><span>lattice_constant.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_stress</span>(<span class="params">out_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(out_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;total   stress&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            stress = line.split()[-<span class="number">1</span>]</span><br><span class="line">            stress = <span class="built_in">float</span>(stress)</span><br><span class="line">            <span class="keyword">return</span> stress</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_lattice_constant</span>(<span class="params">a, in_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(in_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;CELL_PARAMETERS&#x27;</span> <span class="keyword">in</span> lines[i]:</span><br><span class="line">            lines[i+<span class="number">1</span>] = <span class="string">&#x27;&#123;0&#125;   0.0     0.0\n&#x27;</span>.<span class="built_in">format</span>(a)</span><br><span class="line">            lines[i+<span class="number">2</span>] = <span class="string">&#x27;0.0     &#123;0&#125;   0.0\n&#x27;</span>.<span class="built_in">format</span>(a)</span><br><span class="line">            lines[i+<span class="number">3</span>] = <span class="string">&#x27;0.0     0.0     &#123;0&#125;\n&#x27;</span>.<span class="built_in">format</span>(a)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(in_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.writelines(lines)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_espresso</span>(<span class="params">in_path, out_path, np=<span class="number">8</span></span>):</span><br><span class="line">    os.system(<span class="string">&#x27;mpiexec -np &#123;0&#125; pw.x &lt; &#123;1&#125; &gt; &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(np, in_path, out_path))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a_left = <span class="number">10.00</span></span><br><span class="line">    a_right = <span class="number">10.50</span></span><br><span class="line"></span><br><span class="line">    in_path = <span class="string">&#x27;si.stress.in&#x27;</span></span><br><span class="line">    out_path = <span class="string">&#x27;si.stress.out&#x27;</span></span><br><span class="line"></span><br><span class="line">    change_lattice_constant(a_left, in_path)</span><br><span class="line">    run_espresso(in_path, out_path)</span><br><span class="line">    stress_left = read_stress(out_path)</span><br><span class="line"></span><br><span class="line">    change_lattice_constant(a_right, in_path)</span><br><span class="line">    run_espresso(in_path, out_path)</span><br><span class="line">    stress_right = read_stress(out_path)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stress_left = &#123;0&#125; GPa&#x27;</span>.<span class="built_in">format</span>(stress_left))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stress_right = &#123;0&#125; GPa&#x27;</span>.<span class="built_in">format</span>(stress_right))</span><br><span class="line"></span><br><span class="line">    threshold_lattice = <span class="number">1e-10</span></span><br><span class="line">    threshold_pressure = <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(a_left - a_right) &gt; threshold_lattice <span class="keyword">and</span> <span class="built_in">abs</span>(stress_left - stress_right) &gt; threshold_pressure:</span><br><span class="line">        a_middle = (a_left + a_right) / <span class="number">2</span></span><br><span class="line">        change_lattice_constant(a_middle, in_path)</span><br><span class="line">        run_espresso(in_path, out_path)</span><br><span class="line">        stress_middle = read_stress(out_path)</span><br><span class="line">        <span class="keyword">if</span> stress_left * stress_right &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error: stress_left * stress_right &gt; 0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> stress_middle * stress_left &lt; <span class="number">0</span>:</span><br><span class="line">            a_right = a_middle</span><br><span class="line">            stress_right = stress_middle</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a_left = a_middle</span><br><span class="line">            stress_left = stress_middle</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a_left = &#123;0&#125; Bohr, a_right = &#123;1&#125; Bohr, stress_middle = &#123;2&#125; GPa&#x27;</span>.<span class="built_in">format</span>(a_left, a_right, stress_middle))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a = &#123;0&#125; Bohr&#x27;</span>.<span class="built_in">format</span>(a_middle))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stress = &#123;0&#125; GPa&#x27;</span>.<span class="built_in">format</span>(stress_middle))</span><br></pre></td></tr></table></figure>
<p>Remember, before running the script, you have to copy the
<code>si.pw.in</code> to <code>si.stress.in</code>, and make sure that
the <code>ATOMIC_POSITIONS</code> block is changed back to the original
value without any perturbation. Also, here we'd better consistent values
of <code>ecutwfc</code>, <code>K_POINTS</code>, and
<code>conv_thr</code> with the further calculations. Here we just take
<code>70</code>, <code>8 8 8 1 1 1</code>, and <code>1.0d-11</code>,
respectively.</p>
<p>Anyway, the script will yield the result that the lattice constant is
<code>10.20753662109375 Bohr</code>, and we just take it as the new
lattice constant.</p>
<h1 id="construct-supercell-and-displace-patterns">Construct supercell
and displace patterns</h1>
<h2 id="generate-supercell-using-phonopy">Generate supercell using
<code>phonopy</code></h2>
<p>It is already quite boring to write the baseline input file for a
cell of 8 atoms, and it would be impoosible to imagine that we have to
write the input file for a cell of 64 atoms (<span
class="math inline">\(2^3\times 8\)</span>), or even 216 atoms (<span
class="math inline">\(3^3\times 8\)</span>). Fortunately,
<code>phonopy</code> provides a very convenient way to generate
supercells by one line of command. With it installed, simply run the
following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phonopy --qe -d --dim=<span class="string">&quot;2 2 2&quot;</span> -c si.pw.in</span><br></pre></td></tr></table></figure>
<p>Once again, don't forget to check if you changed
<code>si.pw.in</code> to the unperturbed settings. Also, the
<code>--dim</code> option can be whatever you want. For silicon,
<code>"2 2 2"</code> (Si222) is pretty good, but Si333 will be better if
you have the resources and time to do the calculations. Copy and paste
the contents of generated files into a new file <code>si222.pw.in</code>
and modify <code>prefix</code>, <code>nat</code>,
<code>CELL_PARAMETERS</code> and <code>K_POINTS</code>, like the
following:</p>
<figure class="highlight bash"><figcaption><span>si222.pw.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;CONTROL</span><br><span class="line">    calculation = <span class="string">&#x27;scf&#x27;</span></span><br><span class="line">    prefix = <span class="string">&#x27;si222&#x27;</span></span><br><span class="line">    pseudo_dir = <span class="string">&#x27;./pseudo/&#x27;</span></span><br><span class="line">    outdir = <span class="string">&#x27;./tmp/&#x27;</span></span><br><span class="line">    verbosity = <span class="string">&#x27;high&#x27;</span></span><br><span class="line">    tprnfor = .<span class="literal">true</span>.</span><br><span class="line">    tstress = .<span class="literal">true</span>.</span><br><span class="line">    disk_io = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">/</span><br><span class="line">&amp;SYSTEM</span><br><span class="line">    ibrav = 0</span><br><span class="line">    nat = 64</span><br><span class="line">    ntyp = 1</span><br><span class="line">    ecutwfc = 70</span><br><span class="line">/</span><br><span class="line">&amp;ELECTRONS</span><br><span class="line">    conv_thr        = 1.0d-11</span><br><span class="line">    mixing_beta     = 0.7</span><br><span class="line">/</span><br><span class="line">CELL_PARAMETERS bohr</span><br><span class="line">   20.4150732421875    0.0000000000000    0.0000000000000</span><br><span class="line">    0.0000000000000   20.4150732421875    0.0000000000000</span><br><span class="line">    0.0000000000000    0.0000000000000   20.4150732421875</span><br><span class="line">ATOMIC_SPECIES</span><br><span class="line">    Si  28.0855  Si.pz-vbc.UPF</span><br><span class="line">ATOMIC_POSITIONS crystal</span><br><span class="line">    Si   0.0000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">    Si   0.5000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">    Si   0.0000000000000000  0.5000000000000000  0.0000000000000000</span><br><span class="line">    Si   0.5000000000000000  0.5000000000000000  0.0000000000000000</span><br><span class="line">    Si   0.0000000000000000  0.0000000000000000  0.5000000000000000</span><br><span class="line">    Si   0.5000000000000000  0.0000000000000000  0.5000000000000000</span><br><span class="line">    Si   0.0000000000000000  0.5000000000000000  0.5000000000000000</span><br><span class="line">    Si   0.5000000000000000  0.5000000000000000  0.5000000000000000</span><br><span class="line">    Si   0.0000000000000000  0.2500000000000000  0.2500000000000000</span><br><span class="line">    Si   0.5000000000000000  0.2500000000000000  0.2500000000000000</span><br><span class="line">    Si   0.0000000000000000  0.7500000000000000  0.2500000000000000</span><br><span class="line">    Si   0.5000000000000000  0.7500000000000000  0.2500000000000000</span><br><span class="line">    Si   0.0000000000000000  0.2500000000000000  0.7500000000000000</span><br><span class="line">    Si   0.5000000000000000  0.2500000000000000  0.7500000000000000</span><br><span class="line">    Si   0.0000000000000000  0.7500000000000000  0.7500000000000000</span><br><span class="line">    Si   0.5000000000000000  0.7500000000000000  0.7500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.0000000000000000  0.2500000000000000</span><br><span class="line">    Si   0.7500000000000000  0.0000000000000000  0.2500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.5000000000000000  0.2500000000000000</span><br><span class="line">    Si   0.7500000000000000  0.5000000000000000  0.2500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.0000000000000000  0.7500000000000000</span><br><span class="line">    Si   0.7500000000000000  0.0000000000000000  0.7500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.5000000000000000  0.7500000000000000</span><br><span class="line">    Si   0.7500000000000000  0.5000000000000000  0.7500000000000000</span><br><span class="line">    Si   0.2500000000000000  0.2500000000000000  0.0000000000000000</span><br><span class="line">    Si   0.7500000000000000  0.2500000000000000  0.0000000000000000</span><br><span class="line">    Si   0.2500000000000000  0.7500000000000000  0.0000000000000000</span><br><span class="line">    Si   0.7500000000000000  0.7500000000000000  0.0000000000000000</span><br><span class="line">    Si   0.2500000000000000  0.2500000000000000  0.5000000000000000</span><br><span class="line">    Si   0.7500000000000000  0.2500000000000000  0.5000000000000000</span><br><span class="line">    Si   0.2500000000000000  0.7500000000000000  0.5000000000000000</span><br><span class="line">    Si   0.7500000000000000  0.7500000000000000  0.5000000000000000</span><br><span class="line">    Si   0.1250000000000000  0.1250000000000000  0.1250000000000000</span><br><span class="line">    Si   0.6250000000000000  0.1250000000000000  0.1250000000000000</span><br><span class="line">    Si   0.1250000000000000  0.6250000000000000  0.1250000000000000</span><br><span class="line">    Si   0.6250000000000000  0.6250000000000000  0.1250000000000000</span><br><span class="line">    Si   0.1250000000000000  0.1250000000000000  0.6250000000000000</span><br><span class="line">    Si   0.6250000000000000  0.1250000000000000  0.6250000000000000</span><br><span class="line">    Si   0.1250000000000000  0.6250000000000000  0.6250000000000000</span><br><span class="line">    Si   0.6250000000000000  0.6250000000000000  0.6250000000000000</span><br><span class="line">    Si   0.1250000000000000  0.3750000000000000  0.3750000000000000</span><br><span class="line">    Si   0.6250000000000000  0.3750000000000000  0.3750000000000000</span><br><span class="line">    Si   0.1250000000000000  0.8750000000000000  0.3750000000000000</span><br><span class="line">    Si   0.6250000000000000  0.8750000000000000  0.3750000000000000</span><br><span class="line">    Si   0.1250000000000000  0.3750000000000000  0.8750000000000000</span><br><span class="line">    Si   0.6250000000000000  0.3750000000000000  0.8750000000000000</span><br><span class="line">    Si   0.1250000000000000  0.8750000000000000  0.8750000000000000</span><br><span class="line">    Si   0.6250000000000000  0.8750000000000000  0.8750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.1250000000000000  0.3750000000000000</span><br><span class="line">    Si   0.8750000000000000  0.1250000000000000  0.3750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.6250000000000000  0.3750000000000000</span><br><span class="line">    Si   0.8750000000000000  0.6250000000000000  0.3750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.1250000000000000  0.8750000000000000</span><br><span class="line">    Si   0.8750000000000000  0.1250000000000000  0.8750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.6250000000000000  0.8750000000000000</span><br><span class="line">    Si   0.8750000000000000  0.6250000000000000  0.8750000000000000</span><br><span class="line">    Si   0.3750000000000000  0.3750000000000000  0.1250000000000000</span><br><span class="line">    Si   0.8750000000000000  0.3750000000000000  0.1250000000000000</span><br><span class="line">    Si   0.3750000000000000  0.8750000000000000  0.1250000000000000</span><br><span class="line">    Si   0.8750000000000000  0.8750000000000000  0.1250000000000000</span><br><span class="line">    Si   0.3750000000000000  0.3750000000000000  0.6250000000000000</span><br><span class="line">    Si   0.8750000000000000  0.3750000000000000  0.6250000000000000</span><br><span class="line">    Si   0.3750000000000000  0.8750000000000000  0.6250000000000000</span><br><span class="line">    Si   0.8750000000000000  0.8750000000000000  0.6250000000000000</span><br><span class="line">K_POINTS automatic</span><br><span class="line">    4 4 4 1 1 1</span><br></pre></td></tr></table></figure>
<h2 id="obtain-displace-patterns">Obtain displace patterns</h2>
<p>The next step is to obtain the displace patterns for the supercell.
Create a new file <code>si222.alm.in</code> that will be used by
<code>alamode</code> to generate the patterns:</p>
<figure class="highlight bash"><figcaption><span>si222.alm.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si222</span><br><span class="line">  MODE = suggest</span><br><span class="line">  NAT = 64; NKD = 1</span><br><span class="line">  KD = Si</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;interaction</span><br><span class="line">  NORDER = 2  <span class="comment"># 1: harmonic, 2: cubic, ..</span></span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  20.4150732421875 <span class="comment"># factor in Bohr unit</span></span><br><span class="line">  1.0 0.0 0.0 <span class="comment"># a1</span></span><br><span class="line">  0.0 1.0 0.0 <span class="comment"># a2</span></span><br><span class="line">  0.0 0.0 1.0 <span class="comment"># a3</span></span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cutoff </span><br><span class="line">  Si-Si None 10.0</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;position</span><br><span class="line">  1  0.0000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">  1  0.5000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">  1  0.0000000000000000  0.5000000000000000  0.0000000000000000</span><br><span class="line">  1  0.5000000000000000  0.5000000000000000  0.0000000000000000</span><br><span class="line">  1  0.0000000000000000  0.0000000000000000  0.5000000000000000</span><br><span class="line">  1  0.5000000000000000  0.0000000000000000  0.5000000000000000</span><br><span class="line">  1  0.0000000000000000  0.5000000000000000  0.5000000000000000</span><br><span class="line">  1  0.5000000000000000  0.5000000000000000  0.5000000000000000</span><br><span class="line">  1  0.0000000000000000  0.2500000000000000  0.2500000000000000</span><br><span class="line">  1  0.5000000000000000  0.2500000000000000  0.2500000000000000</span><br><span class="line">  1  0.0000000000000000  0.7500000000000000  0.2500000000000000</span><br><span class="line">  1  0.5000000000000000  0.7500000000000000  0.2500000000000000</span><br><span class="line">  1  0.0000000000000000  0.2500000000000000  0.7500000000000000</span><br><span class="line">  1  0.5000000000000000  0.2500000000000000  0.7500000000000000</span><br><span class="line">  1  0.0000000000000000  0.7500000000000000  0.7500000000000000</span><br><span class="line">  1  0.5000000000000000  0.7500000000000000  0.7500000000000000</span><br><span class="line">  1  0.2500000000000000  0.0000000000000000  0.2500000000000000</span><br><span class="line">  1  0.7500000000000000  0.0000000000000000  0.2500000000000000</span><br><span class="line">  1  0.2500000000000000  0.5000000000000000  0.2500000000000000</span><br><span class="line">  1  0.7500000000000000  0.5000000000000000  0.2500000000000000</span><br><span class="line">  1  0.2500000000000000  0.0000000000000000  0.7500000000000000</span><br><span class="line">  1  0.7500000000000000  0.0000000000000000  0.7500000000000000</span><br><span class="line">  1  0.2500000000000000  0.5000000000000000  0.7500000000000000</span><br><span class="line">  1  0.7500000000000000  0.5000000000000000  0.7500000000000000</span><br><span class="line">  1  0.2500000000000000  0.2500000000000000  0.0000000000000000</span><br><span class="line">  1  0.7500000000000000  0.2500000000000000  0.0000000000000000</span><br><span class="line">  1  0.2500000000000000  0.7500000000000000  0.0000000000000000</span><br><span class="line">  1  0.7500000000000000  0.7500000000000000  0.0000000000000000</span><br><span class="line">  1  0.2500000000000000  0.2500000000000000  0.5000000000000000</span><br><span class="line">  1  0.7500000000000000  0.2500000000000000  0.5000000000000000</span><br><span class="line">  1  0.2500000000000000  0.7500000000000000  0.5000000000000000</span><br><span class="line">  1  0.7500000000000000  0.7500000000000000  0.5000000000000000</span><br><span class="line">  1  0.1250000000000000  0.1250000000000000  0.1250000000000000</span><br><span class="line">  1  0.6250000000000000  0.1250000000000000  0.1250000000000000</span><br><span class="line">  1  0.1250000000000000  0.6250000000000000  0.1250000000000000</span><br><span class="line">  1  0.6250000000000000  0.6250000000000000  0.1250000000000000</span><br><span class="line">  1  0.1250000000000000  0.1250000000000000  0.6250000000000000</span><br><span class="line">  1  0.6250000000000000  0.1250000000000000  0.6250000000000000</span><br><span class="line">  1  0.1250000000000000  0.6250000000000000  0.6250000000000000</span><br><span class="line">  1  0.6250000000000000  0.6250000000000000  0.6250000000000000</span><br><span class="line">  1  0.1250000000000000  0.3750000000000000  0.3750000000000000</span><br><span class="line">  1  0.6250000000000000  0.3750000000000000  0.3750000000000000</span><br><span class="line">  1  0.1250000000000000  0.8750000000000000  0.3750000000000000</span><br><span class="line">  1  0.6250000000000000  0.8750000000000000  0.3750000000000000</span><br><span class="line">  1  0.1250000000000000  0.3750000000000000  0.8750000000000000</span><br><span class="line">  1  0.6250000000000000  0.3750000000000000  0.8750000000000000</span><br><span class="line">  1  0.1250000000000000  0.8750000000000000  0.8750000000000000</span><br><span class="line">  1  0.6250000000000000  0.8750000000000000  0.8750000000000000</span><br><span class="line">  1  0.3750000000000000  0.1250000000000000  0.3750000000000000</span><br><span class="line">  1  0.8750000000000000  0.1250000000000000  0.3750000000000000</span><br><span class="line">  1  0.3750000000000000  0.6250000000000000  0.3750000000000000</span><br><span class="line">  1  0.8750000000000000  0.6250000000000000  0.3750000000000000</span><br><span class="line">  1  0.3750000000000000  0.1250000000000000  0.8750000000000000</span><br><span class="line">  1  0.8750000000000000  0.1250000000000000  0.8750000000000000</span><br><span class="line">  1  0.3750000000000000  0.6250000000000000  0.8750000000000000</span><br><span class="line">  1  0.8750000000000000  0.6250000000000000  0.8750000000000000</span><br><span class="line">  1  0.3750000000000000  0.3750000000000000  0.1250000000000000</span><br><span class="line">  1  0.8750000000000000  0.3750000000000000  0.1250000000000000</span><br><span class="line">  1  0.3750000000000000  0.8750000000000000  0.1250000000000000</span><br><span class="line">  1  0.8750000000000000  0.8750000000000000  0.1250000000000000</span><br><span class="line">  1  0.3750000000000000  0.3750000000000000  0.6250000000000000</span><br><span class="line">  1  0.8750000000000000  0.3750000000000000  0.6250000000000000</span><br><span class="line">  1  0.3750000000000000  0.8750000000000000  0.6250000000000000</span><br><span class="line">  1  0.8750000000000000  0.8750000000000000  0.6250000000000000</span><br></pre></td></tr></table></figure>
<p>Here, the mode <code>suggest</code> means that we ask
<code>alamode</code> to generate patterns. And we set the cutoff
parameters empirically. After this, execute the following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alm si222.alm.in &gt; si222.alm.log</span><br></pre></td></tr></table></figure>
<p>The harmonic and anharmonic patterns will be saved as files
<code>si222.pattern_HARMONIC</code> and
<code>si222.pattern_ANHARM3</code>, respectively. With the anharmonic
patterns (16 patterns inside the file), we perturb again the input file
of Quantum Espresso, but this time automatically by using the
<code>displace.py</code> script provided by <code>alamode</code> in its
<code>tools</code> directory.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python displace.py --QE=si222.pw.in --mag=0.01 -pf si222.pattern_ANHARM3</span><br></pre></td></tr></table></figure>
<p>The <code>--mag</code> option specifies the magnitude, and the
<code>-pf</code> option specifies the pattern file. For Si222 (and also
Si333), 16 new input files named from <code>disp01.pw.in</code> to
<code>disp16.pw.in</code> will be generated.</p>
<h1 id="calculate-forces-using-pw.x">Calculate forces using
<code>pw.x</code></h1>
<p>Just perform the calculations of all the input files generated by
<code>displace.py</code>! To be a bit lazy, I submit all the jobs using
a bash script that run through all the input files and submit them to
the queue system of the cluster in my university. It is something like
this:</p>
<figure class="highlight bash"><figcaption><span>_si.disp.submit.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    num=`<span class="built_in">echo</span> <span class="variable">$i</span> | awk <span class="string">&#x27;&#123;printf(&quot;%02d&quot;,$1)&#125;&#x27;</span>`</span><br><span class="line">    <span class="built_in">cp</span> _si.disp.sh _si.disp<span class="variable">$&#123;num&#125;</span>.sh</span><br><span class="line">    <span class="comment"># match patterns like &quot;input=disp.pw*.in&quot;, &quot;output=disp.pw*.out&quot;, change to &quot;input=disp.pw.01.in&quot;, &quot;output=disp.pw.01.out&quot;</span></span><br><span class="line">    sed -i <span class="string">&quot;s/input=disp.pw.in/input=disp<span class="variable">$&#123;num&#125;</span>.pw.in/g&quot;</span> _si.disp<span class="variable">$&#123;num&#125;</span>.sh</span><br><span class="line">    sed -i <span class="string">&quot;s/output=disp.pw.out/output=disp<span class="variable">$&#123;num&#125;</span>.pw.out/g&quot;</span> _si.disp<span class="variable">$&#123;num&#125;</span>.sh</span><br><span class="line">    qsub _si.disp<span class="variable">$&#123;num&#125;</span>.sh</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>which manipulates a submission script <code>_si.disp.sh</code>:</p>
<div class="note danger"><p>The following script is just an example, and is only suitable for the
cluster of my university. You have to modify it according to your own
cluster. Or you can simply run the calculations on your own computer
manually...</p>
</div>
<figure class="highlight bash"><figcaption><span>_si.disp.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#### submit_job.sh START ####</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#$ -cwd</span></span><br><span class="line"><span class="comment"># error = Merged with joblog</span></span><br><span class="line"><span class="comment">#$ -o joblog.$JOB_ID</span></span><br><span class="line"><span class="comment">#$ -j y</span></span><br><span class="line"><span class="comment">## Edit the line below as needed:</span></span><br><span class="line"><span class="comment">#$ -l h_rt=24:00:00,h_data=3G</span></span><br><span class="line"><span class="comment">## Modify the parallel environment</span></span><br><span class="line"><span class="comment">## and the number of cores as needed:</span></span><br><span class="line"><span class="comment">#$ -pe shared 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo job info on joblog:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> started on:   &quot;</span> `hostname -s`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> started on:   &quot;</span> `<span class="built_in">date</span> `</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load the job environment:</span></span><br><span class="line">. /u/local/Modules/default/init/modules.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">## Edit the line below as needed:</span></span><br><span class="line">module load intel/2020.4</span><br><span class="line">module load gcc/10.2.0</span><br><span class="line">module load espresso/6.7.0</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Current Packages:&quot;</span></span><br><span class="line"></span><br><span class="line">module list</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start running...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## substitute the command to run your code</span></span><br><span class="line"><span class="comment">## in the two lines below:</span></span><br><span class="line"><span class="built_in">cd</span> /PATH/TO/THE/WORKING/DIRECTORY/</span><br><span class="line"></span><br><span class="line">input=disp.pw.in</span><br><span class="line">output=disp.pw.out</span><br><span class="line"></span><br><span class="line">mpirun -np 16 pw.x &lt; <span class="variable">$&#123;input&#125;</span> &gt; <span class="variable">$&#123;output&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># try to determine if there is &quot;JOB DONE&quot; in the output file, if not, echo a warning message</span></span><br><span class="line"><span class="keyword">if</span> grep -q <span class="string">&quot;JOB DONE&quot;</span> <span class="variable">$&#123;output&#125;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;PW finished successfully&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> for <span class="variable">$input</span> ended succesffully&quot;</span> &gt;&gt; __submit_job.<span class="built_in">log</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;PW may not finished successfully&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> for <span class="variable">$input</span> FAILED!&quot;</span> &gt;&gt; __submit_job.<span class="built_in">log</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo job info on joblog:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> ended on:   &quot;</span> `hostname -s`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Job <span class="variable">$JOB_ID</span> ended on:   &quot;</span> `<span class="built_in">date</span> `</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="comment">#### submit_job.sh STOP ####</span></span><br></pre></td></tr></table></figure>
<p>When all the calculations are finished, we extract the forces from
the output files by using the <code>extract.py</code> script that is
also provided by <code>alamode</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python extract.py --QE=si222.pw.in ./disp*.pw.out &gt; si222.DFSET_ANHARM3</span><br></pre></td></tr></table></figure>
<h1 id="fit-ifcs-by-using-alm">Fit IFCs by using <code>alm</code></h1>
<p>Make a copy of the <code>alm</code> input file
<code>si222.alm.in</code>, name it as
<code>si222.alm.optimize.in</code>, change the following settings:</p>
<figure class="highlight diff"><figcaption><span>si222.alm.optimize.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">...</span><br><span class="line"><span class="deletion">-  MODE = suggest</span></span><br><span class="line"><span class="addition">+  MODE = optimize</span></span><br><span class="line">...</span><br><span class="line">/</span><br><span class="line"><span class="addition">+&amp;optimize</span></span><br><span class="line"><span class="addition">+  DFSET = si222.DFSET_ANHARM3</span></span><br><span class="line"><span class="addition">+/</span></span><br></pre></td></tr></table></figure>
<p>Then perfom the fitting:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alm si222.alm.optimize.in &gt; si222.alm.optimize.log</span><br></pre></td></tr></table></figure>
<p>This will generate <code>si222.xml</code>, <code>si222.fcs</code>
that are the fitted IFCs, and <code>si222.alm.optimize.log</code> that
is the log file of the fitting process.</p>
<h1 id="phonon-dispersion-relation-and-density-of-states">Phonon
dispersion relation and density of states</h1>
<p>First create a new input file for <code>anphon</code>, which is one
of the packages of <code>alamode</code>:</p>
<figure class="highlight bash"><figcaption><span>si222.phonon.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si222</span><br><span class="line">  MODE   = phonons</span><br><span class="line">  FCSXML = si222.xml</span><br><span class="line"></span><br><span class="line">  NKD = 1; KD = Si</span><br><span class="line">  MASS = 28.0855</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  10.20753662109375</span><br><span class="line">  0.0 0.5 0.5</span><br><span class="line">  0.5 0.0 0.5</span><br><span class="line">  0.5 0.5 0.0</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;kpoint</span><br><span class="line">  1  <span class="comment"># KPMODE = 1: line mode</span></span><br><span class="line">  G 0.0 0.0 0.0 X 0.5 0.5 0.0 51</span><br><span class="line">  X 0.5 0.5 1.0 G 0.0 0.0 0.0 51</span><br><span class="line">  G 0.0 0.0 0.0 L 0.5 0.5 0.5 51</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>It is worth noting that the <code>kpoint</code> field is selected to
be the line mode, meaning that anphon will calculate phonon dispersion
relation along the lines that are specified.</p>
<p>Perform the calculation by:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anphon si222.phonon.in &gt; si222.phonon.log</span><br></pre></td></tr></table></figure>
<p>Using another script <code>plotband.py</code> provided by
<code>alamode</code>, the phonon band structure can be quickly
plotted:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python plotband.py si222.bands</span><br></pre></td></tr></table></figure>
<img src="/images/2023/ab-initio/band.png" class="" width="500" title="Phonon band structure">
<p>As for the density of states, just change the <code>kpoint</code>
field to:</p>
<figure class="highlight diff"><figcaption><span>si222.phonon.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;kpoint</span><br><span class="line"><span class="deletion">-  1  # KPMODE = 1: line mode</span></span><br><span class="line"><span class="deletion">-  G 0.0 0.0 0.0 X 0.5 0.5 0.0 51</span></span><br><span class="line"><span class="deletion">-  X 0.5 0.5 1.0 G 0.0 0.0 0.0 51</span></span><br><span class="line"><span class="deletion">-  G 0.0 0.0 0.0 L 0.5 0.5 0.5 51</span></span><br><span class="line"><span class="addition">+  2</span></span><br><span class="line"><span class="addition">+  20 20 20</span></span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>perform the same command again, <code>anphon</code> will create
<code>si222.dos</code> and <code>si.thermo</code> that are the density
of states and the thermodynamic properties. To see the DoS, just use
<code>plotdos.py</code>, with the following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python plotdos.py --emax 550 --nokey si222.dos</span><br></pre></td></tr></table></figure>
<img src="/images/2023/ab-initio/dos.png" class="" width="500" title="Density of states">
<h1 id="calculate-thermal-conductivity">Calculate thermal
conductivity</h1>
<p>Now it is time to calculate the thermal conductivity. We still use
<code>anphon</code>, and let's create a config file
<code>si222.RTA.in</code> similar to the one of phonon dispersion
relation:</p>
<figure class="highlight bash"><figcaption><span>si222.RTA.in</span></figcaption><table><tr><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si222</span><br><span class="line">  MODE   = RTA</span><br><span class="line">  FCSXML = si222.xml</span><br><span class="line"></span><br><span class="line">  NKD = 1; KD = Si</span><br><span class="line">  MASS = 28.0855</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  10.20753662109375</span><br><span class="line">  0.0 0.5 0.5</span><br><span class="line">  0.5 0.0 0.5</span><br><span class="line">  0.5 0.5 0.0</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;kpoint</span><br><span class="line">  2</span><br><span class="line">  20 20 20</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>where <code>mode=RTA</code> means that we are going to use
relaxation-time approximation (RTA) to calculate the thermal
conductivity. The <code>FCSXML</code> option specifies the IFCs file
that we just obtained. The <code>cell</code> block, as you can see,
specifies a primitive cell of Silicon monocrystalline, and it is surely
different than the supercell that we used above. The <code>kpoint</code>
block specifies the number of wavevectors in each direction of the
reciprocal space, and it can be set to quite large comparing with that
of the supercell.</p>
<p>Perform the calculation by:</p>
<div class="note primary"><p>Although the official documentation of <code>alamode</code> claims
that <code>anphon</code> does support MPI, the parallel execution was
not working on both my computer (M1 Max Macbook Pro) and on the cluster
of my university (Intel x86). Luckily, it is not that slow to run on a
single core. Just be patient for a while.</p>
</div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anphon si222.RTA.<span class="keyword">in</span> &gt; si222.RTA.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>will give the thermal conductivity up to 1000 K, stored in
<code>si222.kl</code>, and all other information is stored in
<code>si222.result</code>. Here we plot the thermal conductivity, and
compare it with the data in literature, shown below:</p>
<img src="/images/2023/ab-initio/thermal_conductivity.png" class="" width="500" title="Thermal conductivity">
<p>If we redo all the stuff above for Si333, a nearly same result will
be obtained, and we plot the data from 250 K to 450 K, it is shown that
the difference between the calculated data for Si222 and Si333 is within
4.22 W/mK, and is about 2.5% of the value of Si222.</p>
<img src="/images/2023/ab-initio/thermal_conductivity_333.png" class="" width="500" title="Thermal conductivity comparing Si222 and Si333">
<p>It is so amazing that the calculated thermal conductivity is just in
very good agreement with the experimental data. This is the power of
physics, that we can absoultely calculate anything in the <em>ab
initio</em> way, and they just do the job!</p>
<h1 id="references">References</h1>
<ol type="1">
<li><a
href="https://alamode.readthedocs.io/en/latest/index.html">alamode
documentation</a></li>
<li><a href="https://www.quantum-espresso.org/">Quantum
Espresso</a></li>
<li><a href="https://phonopy.github.io/phonopy/">phonopy
documentation</a></li>
<li><a
href="https://icme.hpc.msstate.edu/mediawiki/index.php/How_to_make_Supercell_for_Quantum_ESPRESSO.html">How
to make Supercell for Quantum ESPRESSO</a></li>
<li><a
href="https://journals.aps.org/pr/abstract/10.1103/PhysRev.130.1743">H.
R. Shanks, P. D. Maycock, P. H. Sidles, and G. C. Danielson. Thermal
Conductivity of Silicon from 300 to 1400Â°K. <em>Phys. Rev.</em> 130,
1743 â€“ Published 1 June 1963</a></li>
</ol>
]]></content>
      <categories>
        <category>Solid State Physics</category>
        <category>Ab Initio Calculation</category>
      </categories>
      <tags>
        <tag>Phonon</tag>
        <tag>Interatomic force constant</tag>
        <tag>Dispersion relation</tag>
        <tag>Ab initio calculation</tag>
        <tag>Relaxation time approximation</tag>
      </tags>
  </entry>
  <entry>
    <title>Solve phonon dispersion relation by the classical approach</title>
    <url>/2023/10/phonon-dispersion/</url>
    <content><![CDATA[<p>Consider a crystal in which unit cells are labeled by <span
class="math inline">\(\boldsymbol{l}\)</span>, and atoms in each cell
are labeled by <span class="math inline">\(\boldsymbol{b}\)</span>. The
total energy of the system, noted by <span
class="math inline">\(\mathcal{V}\)</span>, can be expanded using
Taylor's expansion (greek letters mean direction): <span
class="math display">\[
\begin{aligned}
    \mathcal{V} = &amp; \mathcal{V}_0 +
\underbrace{\sum_{\boldsymbol{l},\boldsymbol{b}}\sum_{\alpha}
\Phi_{\alpha}(\boldsymbol{l}\boldsymbol{b})
u_{\alpha}(\boldsymbol{l}\boldsymbol{b})}_{\mathcal{V}_1} +
\underbrace{\frac{1}{2}\sum_{\boldsymbol{l},\boldsymbol{b},\boldsymbol{l}&#39;,\boldsymbol{b}&#39;}\sum_{\alpha,\beta}
\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)u_{\alpha}(\boldsymbol{l}\boldsymbol{b})u_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)}_{\mathcal{V}_2}
+ \cdots\\
    &amp; \quad +
\frac{1}{n!}\sum_{\boldsymbol{l}_1,\boldsymbol{b}_1,\boldsymbol{l}_2,\boldsymbol{b}_2,\cdots,\boldsymbol{l}_n,\boldsymbol{b}_n}\sum_{\alpha_1,\alpha_2,\cdots,\alpha_n}\Phi_{\alpha_1,\alpha_2,\cdots,\alpha_n}(\boldsymbol{l}_1,\boldsymbol{b}_1;\boldsymbol{l}_2,\boldsymbol{b}_2;\cdots;\boldsymbol{l}_n,\boldsymbol{b}_n)u_{\alpha_1}(\boldsymbol{l}_1,\boldsymbol{b}_1)\cdots
u_{\alpha_n}(\boldsymbol{l}_n \boldsymbol{b}_n)
\end{aligned}
\]</span> Where we note the nth order interatomic force constants (IFCs)
using <span class="math inline">\(\Phi\)</span>, and we note <span
class="math inline">\(u_{\alpha}(\boldsymbol{l}\boldsymbol{b})\)</span>
represent the spatial deviation of atom <span
class="math inline">\(\boldsymbol{b}\)</span> in cell <span
class="math inline">\(\boldsymbol{l}\)</span> along <span
class="math inline">\(\alpha\)</span> direction.<span id="more"></span> It is clear
to see that:</p>
<ul>
<li>The first order IFCs should be cancelled, that <span
class="math inline">\(\mathcal{V}_1=0\)</span>, due to that the system
is stable.</li>
<li>The second order term <span
class="math inline">\(\mathcal{V}_2\)</span> represent the combination
of many interatomic harmonic oscillators.</li>
</ul>
<p>Let's ignore the higher order term, keeping only <span
class="math inline">\(\mathcal{V}_2\)</span>. Using Newton's second law,
<span class="math display">\[
F_{\boldsymbol{l}\boldsymbol{b}\alpha} = m_{\boldsymbol{b}}
\ddot{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b}) =-\frac{\partial
\mathcal{V}}{\mathcal{u_{\alpha}}(\boldsymbol{l}\boldsymbol{b})}= -
\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}
\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
u_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;),\quad \forall
\boldsymbol{l},\boldsymbol{b},\alpha
\]</span> Note that the above equation exploits the symmetry of second
order IFCs, that <span
class="math inline">\(\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
=
\Phi_{\beta,\alpha}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;,\boldsymbol{l}\boldsymbol{b})\)</span>.
We now seek a solution in the form of plane waves: <span
class="math display">\[
u_{\alpha} (\boldsymbol{l}\boldsymbol{b}) =
\frac{1}{\sqrt{m_{\boldsymbol{b}}}} \sum_{\boldsymbol{q}}
U_{\alpha}(\boldsymbol{q};\boldsymbol{b})\exp \big[ i
\boldsymbol{q}\cdot \boldsymbol{l}-\omega t\big]
\]</span></p>
<div class="note info"><ul>
<li>The purpose of seaking a solution that is multiplied by <span
class="math inline">\(1/\sqrt{m_{\boldsymbol{b}}}\)</span> is just to
make the form of dynamical matrix simple and beautiful, so don't be
confused.</li>
<li>The value <span
class="math inline">\(U_{\alpha}(\boldsymbol{q};\boldsymbol{b})\)</span>
is complex. Specifically, it contains the phase information of atom
<span class="math inline">\(\boldsymbol{b}\)</span>.</li>
</ul>
</div>
<p>A specific wavevector <span
class="math inline">\(\boldsymbol{q}\)</span> yields, <span
class="math display">\[
\omega^2 \sqrt{m_{\boldsymbol{b}}}
U_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \exp
\big[i\boldsymbol{q}\cdot\boldsymbol{l}-\omega t\big] =
-\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\frac{1}{\sqrt{m_{\boldsymbol{b}&#39;}}}U_{\beta}(\boldsymbol{q};\boldsymbol{b}&#39;)\exp\big[i\boldsymbol{q}\cdot\boldsymbol{l}&#39;-\omega
t\big]
\]</span> Cancel the exponential term on both sides. Notice that due to
translational invariance, <span
class="math inline">\(\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)=\Phi_{\alpha,\beta}(\boldsymbol{0}\boldsymbol{b};(\boldsymbol{l}-\boldsymbol{l}&#39;)\boldsymbol{b}&#39;)\)</span>,
thus, <span class="math display">\[
\begin{aligned}
  \omega^2 \sqrt{m_{\boldsymbol{b}}}
U_{\alpha}(\boldsymbol{q};\boldsymbol{b}) &amp;=
-\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\frac{1}{\sqrt{m_{\boldsymbol{b}&#39;}}}U_{\beta}(\boldsymbol{q};\boldsymbol{b}&#39;)\exp\big[i\boldsymbol{q}\cdot(\boldsymbol{l}&#39;-\boldsymbol{l})\big]\\
  &amp;=
-\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}\Phi_{\alpha,\beta}(\boldsymbol{0}\boldsymbol{b};(\boldsymbol{l}&#39;-\boldsymbol{l})\boldsymbol{b}&#39;)
\frac{1}{\sqrt{m_{\boldsymbol{b}&#39;}}}U_{\beta}(\boldsymbol{q};\boldsymbol{b}&#39;)\exp\big[i\boldsymbol{q}\cdot(\boldsymbol{l}&#39;-\boldsymbol{l})\big]\\
  &amp;=
-\sum_{\boldsymbol{l}&#39;\boldsymbol{b}&#39;}\sum_{\beta}\Phi_{\alpha,\beta}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\frac{1}{\sqrt{m_{\boldsymbol{b}&#39;}}}U_{\beta}(\boldsymbol{q};\boldsymbol{b}&#39;)\exp\big[i\boldsymbol{q}\cdot\boldsymbol{l}&#39;\big]
\end{aligned}
\]</span> Therefore, if we note a matrix called "dynamical matrix", as:
<span class="math display">\[
D_{\alpha\beta} (\boldsymbol{b}\boldsymbol{b}&#39; | \boldsymbol{q}) =
\frac{1}{\sqrt{m_{\boldsymbol{b}}m_{\boldsymbol{b}&#39;}}}
\sum_{\boldsymbol{l}&#39;}
\Phi_{\alpha,\beta}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)\exp[i\boldsymbol{q}\cdot\boldsymbol{l}&#39;]
\]</span> The dynamical equations are thus in the form of matrix
multiplication, <span class="math display">\[
\omega^2 U_{\alpha} (\boldsymbol{q};\boldsymbol{b}) =
\sum_{\boldsymbol{b}&#39;,\beta}D_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
U_{\beta} (\boldsymbol{q};\boldsymbol{b}&#39;)
\]</span> Solving the above equation, we find that <span
class="math inline">\(\omega\)</span> is in fact the eigenvalue of the
dynamical matrix. Due to that <span
class="math inline">\(D_{\cdot,\cdot}(\cdot,\cdot|\boldsymbol{q})\)</span>
is a matrix of <span class="math inline">\(3p\times 3p\)</span>, where
<span class="math inline">\(p\)</span> is the number of atoms per unit
cell, and <span class="math inline">\(3\)</span> is the directions that
<span class="math inline">\(\alpha,\beta\)</span> can take, for any
given <span class="math inline">\(\boldsymbol{q}\)</span>, there are
<span class="math inline">\(3p\)</span> eigenvalues and <span
class="math inline">\(3p\)</span> eigenvectors, that correspond to
different phonon branches.</p>
<p><strong>Example: 1D diatomic chain</strong></p>
<p>Consider the 1D diatomic chain as following:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> g     g     g     g     g</span><br><span class="line">---[m]---[M]---[m]---[M]---</span><br><span class="line">     |&lt;--- a ---&gt;|</span><br></pre></td></tr></table></figure>
<p>The total energy is: <span class="math display">\[
U= \frac{1}{2}g\sum_n \left[(u_{n,1}-u_{n,2})^2 +
(u_{n,2}-u_{n+1,1})^2\right]
\]</span> where <span class="math inline">\(n\)</span> labels the unit
cell, <span class="math inline">\(1\)</span> and <span
class="math inline">\(2\)</span> represent <span
class="math inline">\(M\)</span> or <span
class="math inline">\(m\)</span>. The dynamical matrix is <span
class="math inline">\(2\times 2\)</span>, due to that there are two
atoms in each unit cell, and there is only one direction. According to
the definition, the dynamical matrix is written as, <span
class="math display">\[
D_q = \begin{bmatrix}
\frac{2g}{M} &amp; -\frac{g}{\sqrt{Mm}}(1+e^{-iqa})\\
-\frac{g}{\sqrt{Mm}}(1+e^{iqa}) &amp; \frac{2g}{m}
\end{bmatrix}
\]</span> The two eigenvalues are: <span class="math display">\[
\Rightarrow \omega^2 = g \left(\frac{1}{M} + \frac{1}{m}\right) \pm
g\sqrt{\left(\frac{1}{M} + \frac{1}{m}\right)^2-\frac{4}{Mm}
\sin^2\left(\frac{qa}{2}\right)}
\]</span> If we plot the two branches from <span
class="math inline">\(q=-\pi/a\)</span> to <span
class="math inline">\(q=\pi/a\)</span>, the dispersion relation will be
shown as:</p>
<p><img src="/images/2023/dispersion.png" alt="dispersion" style="zoom: 25%;" /></p>
]]></content>
      <categories>
        <category>Solid State Physics</category>
      </categories>
      <tags>
        <tag>Phonon</tag>
        <tag>Interatomic force constant</tag>
        <tag>Dispersion relation</tag>
        <tag>Dynamical matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Fermi&#39;s golden rule</title>
    <url>/2023/10/golden-rule/</url>
    <content><![CDATA[<h1 id="perturbation-of-a-quantum-system">Perturbation of a quantum
system</h1>
<p>Consider a quantum system that is characterized by a Hamiltonian
<span class="math inline">\(\hat{H}_0\)</span>. Note that its
eigenstates are represented by <span
class="math inline">\(\Phi_{n}=\phi_{n}\exp(-iE_n t/\hbar),
n=1,2,\dots\)</span>, thus the time-independent SchrÃ¶dinger equation is
given by</p>
<p><span class="math display">\[
\hat{H}_0\phi_{n} = E_{n}\phi_{n}
\]</span></p>
<p>Now, we perturb the system by adding a perturbation <span
class="math inline">\(\hat{\mathcal{V}}(t)\)</span>, by which the new
Hamiltonian becomes <span class="math inline">\(\hat{H} = \hat{H}_0 +
\hat{\mathcal{V}}(t)\)</span>, and we try to solve the new SchrÃ¶dinger
equation. Note that those eigenstates constitute a complete set,
thus,</p>
<p><span class="math display">\[
\begin{aligned}
    \underbrace{\left( \hat{H}_0 +
\hat{\mathcal{V}}(t)\right)}_{\bar{H}} \underbrace{\sum_{j} c_{j}(t)
\Phi_{j}}_{\Phi} = i\hbar \frac{\partial}{\partial t}
\underbrace{\sum_{j} c_{j}(t) \Phi_{j}}_{\Phi}
\end{aligned}
\]</span></p>
<p>Due to that for any <span class="math inline">\(j\)</span>, <span
class="math inline">\(\hat{H}\Phi_j = i\hbar\frac{\partial}{\partial
t}\Phi_j\)</span>, the above equation can be rewritten by cancelling
stuff related with the original Hamiltonian <span
class="math inline">\(\hat{H}_0\)</span>,</p>
<p><span class="math display">\[
\hat{\mathcal{V}}(t) \sum_{j} c_j (t) \Phi_{j}= i\hbar \sum_j \Phi_{j}
\frac{\mathrm{d} c_j (t)}{\mathrm{d} t}
\]</span></p>
<p>Mathematically, for any <span class="math inline">\(f\)</span>, we
can try to multiply <span class="math inline">\(\Phi_f^*\)</span> on
both sides of the above equation, and then integrate over the whole
space, thus,</p>
<p><span class="math display">\[
\sum_{j} c_j (t) \Braket{\Phi_f | \hat{\mathcal{V}}(t) | \Phi_j} =
i\hbar \frac{\mathrm{d} c_f (t)}{\mathrm{d} t}
\]</span></p>
<p>The braket on the left side can be further expressed as,</p>
<p><span class="math display">\[
\Braket{\Phi_f | \hat{\mathcal{V}}(t) | \Phi_j} =
\underbrace{\Braket{\phi_f | \hat{\mathcal{V}}(t) | \phi_j}}_{\equiv
\mathcal{V}_{fj}} \exp\left( \frac{i(E_f - E_j)t}{\hbar} \right)
\]</span></p>
<p>Therefore, our task to study the perturbated system is then relying
on the following equations:</p>
<p><span class="math display">\[
i\hbar \frac{\mathrm{d}c_f (t)}{\mathrm{d}t} = \sum_{j} \mathcal{V}_{fj}
c_j (t) e^{\frac{i (E_f-E_j)t}{\hbar}},\quad \forall f
\]</span></p>
<p>Notice that the above equation is a set of coupled differential
equations that depict the transitions from different states <span
class="math inline">\(\phi_{n}\)</span>. It is then clear to say, if we
want to study the transition from state <span
class="math inline">\(i\)</span> to state <span
class="math inline">\(f\)</span>, we will give the initial
conditions:</p>
<p><span class="math display">\[
c_j(t)\Big|_{t=0} = \delta_{ij}
\]</span></p>
<h1
id="st-order-approximation-of-time-independent-perturbation">1st-order
approximation of time-independent perturbation</h1>
<p>We now consider a simple case where the perturbation is
time-independent, i.e., <span class="math inline">\(\hat{\mathcal{V}}(t)
= \hat{\mathcal{V}}\)</span>. Also, we only consider the transition from
state <span class="math inline">\(i\)</span> to state <span
class="math inline">\(f\)</span>, that is to set <span
class="math inline">\(c_j(t)|_{t=0}=\delta_{ij}\)</span>. The
first-order approximation of such problem is given by,</p>
<p><span class="math display">\[
i\hbar \frac{\mathrm{d}c_f (t)}{\mathrm{d}t} = \mathcal{V}_{fi}
\cancelto{1}{c_i (t)} e^{\frac{i (E_f-E_i)t}{\hbar}}
\]</span></p>
<p><span class="math display">\[
\Rightarrow c_f(t) = -\frac{\mathcal{V}_{fi}}{E_f-E_i} e^{\frac{i
(E_f-E_i)t&#39;}{\hbar}} \Big|_{t&#39;=0}^{t&#39;=t} =
-\frac{\mathcal{V}_{fi}t}{\hbar} \frac{\sin
((E_j-E_i)t/2\hbar)}{(E_j-E_i)t/2\hbar} i e^{i(E_j-E_i)t/2\hbar}
\]</span></p>
<p>The module of the final state <span class="math inline">\(f\)</span>
is then given by,</p>
<p><span class="math display">\[
\begin{aligned}
    \left|c_f (t)\right|^2 &amp;= |\mathcal{V}_{fi}|^2
\left(\frac{t}{\hbar}\frac{\sin ((E_j-E_i)t/2\hbar)}{(E_j-E_i)t/2\hbar}
\right)^2\\
    &amp;= \frac{2\pi}{\hbar} |\mathcal{V}_{fi}|^2 t
\times\delta(E_f-E_i)
\end{aligned}
\]</span></p>
<div class="note primary"><p>When we are talking about a quantum mode that has a frequency <span
class="math inline">\(\sim\omega\)</span>, the time scale should be much
larger than <span class="math inline">\(1/\omega\)</span>. It is normal
that the scale of energy difference is <span class="math inline">\(\sim
\hbar\omega\)</span>. Thus, except for the case where <span
class="math inline">\(E_f=E_i\)</span>, the term <span
class="math inline">\(\frac{(E_j-E_i)t}{2\hbar} \gg
\frac{(E_j-E_i)}{\hbar\omega}\sim 1\)</span>, making the term <span
class="math inline">\(\sin
((E_j-E_i)t/2\hbar)/((E_j-E_i)t/2\hbar)\)</span> to be either <span
class="math inline">\(1\)</span> or <span
class="math inline">\(0\)</span>. Also, for t much larger than <span
class="math inline">\(1/\omega\)</span>, with <span
class="math inline">\(|\mathcal{V}|_{fi}\)</span> the same magnitude as
<span class="math inline">\(\hbar\omega\)</span>, the whole term is then
proportional to the dirac delta function <span
class="math inline">\(\delta(E_f-E_i)\)</span>.</p>
<p>After careful examination, it is written as,</p>
<p><span class="math display">\[
\left(\frac{t}{\hbar}\frac{\sin ((E_j-E_i)t/2\hbar)}{(E_j-E_i)t/2\hbar}
\right)^2 = \frac{2\pi}{\hbar} t \times\delta(E_f-E_i)
\]</span></p>
<p>due to that <span class="math inline">\(\int_{-\infty}^{\infty} (\sin
x)^2/x^2 \mathrm{d}x = \pi\)</span>.</p>
</div>
<p>The transition rate can be read from <span class="math inline">\(|c_f
(t)|^2\)</span>:</p>
<p><span class="math display">\[
W_{fi} = \frac{2\pi}{\hbar} |\mathcal{V}_{fi}|^2 \delta(E_f-E_i)
\]</span></p>
<p>This is the very golden rule that we are looking for. It is the basis
of the derivation of the scattering rate in the <a
href="/2023/10/anharmonicity">previous post</a>, where we use the
anharmonic potential as the perturbation with respect to the harmonic
Hamiltonian.</p>
<h1 id="reference">Reference</h1>
<ol type="1">
<li>Davies, John H., Scattering Rates: the Golden Rule (A chapter from
the book <em>The Physics of Low-dimensional Semiconductors: An
Introduction</em>).</li>
<li>Griffths, David J., <em>Introduction to Quantum Mechanics</em>.</li>
</ol>
]]></content>
      <categories>
        <category>Quantum Physics</category>
      </categories>
      <tags>
        <tag>Fermi&#39;s golden rule</tag>
        <tag>Quantum physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Derive phonon scattering rate from anharmonic potential</title>
    <url>/2023/10/anharmonicity/</url>
    <content><![CDATA[<h1 id="hamiltonian-of-a-crystal">Hamiltonian of a crystal</h1>
<p>Like what we did in the <a
href="/2023/10/phonon-dispersion/">previous post</a>, we would like to
do the same thing to the crystal, but in a quantum way, and also
including the anharmonic potential, i.e. the third-order term in the
Taylor expansion of the interatomic potential energy.</p>
<p>Starting from the interatomic potential, which is always expressed by
the IFCs expressed by <span
class="math inline">\(\Phi_{\alpha_1\alpha_2\dots\alpha_n}(\boldsymbol{l}_1,\boldsymbol{b}_1;\boldsymbol{l}_2,\boldsymbol{b}_2,\dots,\boldsymbol{l}_n,\boldsymbol{b}_n)\)</span>,
with <span class="math inline">\(\alpha_i\)</span> denotes direction,
<span class="math inline">\(\boldsymbol{l}_i\)</span> denotes the
lattice site, and <span class="math inline">\(\boldsymbol{b}_i\)</span>
denotes the basis atom. The interatomic potental is: <span
class="math display">\[
\begin{aligned}
    \mathcal{V} = &amp; \mathcal{V}_0 + \cancel{\mathcal{V}_1} \\
    &amp; +
\underbrace{\frac{1}{2}\sum_{\boldsymbol{l},\boldsymbol{b},\boldsymbol{l}&#39;,\boldsymbol{b}&#39;}\sum_{\alpha,\beta}
\Phi_{\alpha,\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)u_{\alpha}(\boldsymbol{l}\boldsymbol{b})u_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)}_{\mathcal{V}_2}
+ \cdots\\
    &amp; + \underbrace{
        \frac{1}{3!}\sum_{\boldsymbol{l},\boldsymbol{b},\boldsymbol{l}&#39;,\boldsymbol{b}&#39;,\boldsymbol{l}&#39;&#39;,\boldsymbol{b}&#39;&#39;}\sum_{\alpha,\beta,\gamma}
\Phi_{\alpha,\beta,\gamma}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)u_{\alpha}(\boldsymbol{l}\boldsymbol{b})u_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)u_{\gamma}(\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)
    }_{\mathcal{V}_3} + \cdots
\end{aligned}
\]</span></p>
<p>Here, we use <span
class="math inline">\({u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})\)</span>
to note the spatial deviation of atom <span
class="math inline">\(\boldsymbol{b}\)</span> in cell <span
class="math inline">\(\boldsymbol{l}\)</span> along <span
class="math inline">\(\alpha\)</span> direction, relative to the
equilibrium position. Until here, everyone including Newton is happy, as
all we wrote is classical, and all the terms are just numbers.</p>
<p>Classical approach is useful, as it surely can depict the
oscillations in a crystal. But it is not enough to reveal the concept of
phonon, which is quantized by quantum mechanics. So we have to turn to
the quantum world, where everything is controlled by the SchrÃ¶dinger
equation, and the Hamiltonian is the key to it.</p>
<div class="note default"><p>Recall the (time-independent) many-body SchrÃ¶dinger equation:</p>
<p><span class="math display">\[
\hat{H} \Psi(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N) =
E \Psi(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N)
\]</span></p>
<p>where <span class="math inline">\(\hat{H} = \sum_{i=1}^N
\frac{\hat{\boldsymbol{p}}_i^2}{2m_i} +
\hat{\mathcal{V}}(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N)\)</span>
is the Hamiltonian of the system, and <span
class="math inline">\(\Psi(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N)\)</span>
is the wavefunction, <span class="math inline">\(E\)</span> is the total
energy. Generally we love the following simplification to the
wavefunction:</p>
<p><span class="math display">\[
\Psi(\boldsymbol{r}_1,\boldsymbol{r}_2,\dots,\boldsymbol{r}_N) =
\prod_{i=1}^N \psi(\boldsymbol{r}_i)
\]</span></p>
<p>that allows us to rewrite the many-body SchrÃ¶dinger equation as:</p>
<p><span class="math display">\[
\hat{H}_i \psi(\boldsymbol{r}_i) = E_i \psi(\boldsymbol{r}_i),
\quad\forall i=1,2,\dots,N
\]</span></p>
<p>with <span class="math inline">\(\hat{H}_i =
\frac{\hat{\boldsymbol{p}}_i}{2 m_i} + \hat{\mathcal{V}}\)</span>.</p>
</div>
<p>Using the potential energy we wrote, the Hamiltonian of a crystal is
thus:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{H} = &amp; \sum_{\boldsymbol{l}\boldsymbol{b}} \frac{\hat{p}^2
(\boldsymbol{l}\boldsymbol{b})}{2m_{\boldsymbol{b}}}\\
    &amp; + \underbrace{\frac{1}{2}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;}
\sum_{\alpha\beta}
\Phi_{\alpha\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})
\hat{u}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)}_{\hat{V}_2}\\
    &amp; + \underbrace{\frac{1}{3!}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;}
\sum_{\alpha\beta\gamma}
\Phi_{\alpha\beta\gamma}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})
\hat{u}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\hat{u}_{\gamma}(\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)}_{\hat{\mathcal{V}}_3}
+ \dots\\
\end{aligned}
\]</span></p>
<p>Note that the deviations <span
class="math inline">\(\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})\)</span>,
the momentum <span
class="math inline">\(\hat{\boldsymbol{p}}(\boldsymbol{l}\boldsymbol{b})\)</span>
are operators rather than numbers. Their commutation relations are:</p>
<p><span class="math display">\[
[\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b}),
\hat{p}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)] =
i\hbar\delta_{\alpha\beta}\delta_{\boldsymbol{l}\boldsymbol{l}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}
\]</span></p>
<p>where <span class="math inline">\(\hat{\boldsymbol{u}}\)</span> is
the vector form of the deviation operators.</p>
<h1 id="diagonal-representation-of-the-hamiltonian">Diagonal
representation of the Hamiltonian</h1>
<h2 id="boldsymbolqboldsymbolb-representation"><span
class="math inline">\((\boldsymbol{q},\boldsymbol{b})\)</span>
representation</h2>
<p>The Hamiltonian we wrote is not diagonal, which means that the
eigenstates of the Hamiltonian are not the same as the basis we used. We
need to transform the Hamiltonian into a diagonal form, so that the
eigenstates of the Hamiltonian are the same as the basis we used.</p>
<p>Due to that we are dealing with a cyclic system, that we use periodic
boundary condition for <span class="math inline">\(N_0 = N_1\times
N_2\times N_3\)</span> unit cells, the operators <span
class="math inline">\(\hat{\boldsymbol{u}}(\boldsymbol{l}\boldsymbol{b})\)</span>
and <span
class="math inline">\(\hat{\boldsymbol{p}}(\boldsymbol{l}\boldsymbol{b})\)</span>
can be represented in the Fourier's fashion:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{\boldsymbol{u}}(\boldsymbol{l}\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{N_0}} \sum_{\boldsymbol{q}} \hat{\boldsymbol{X}}
(\boldsymbol{q};\boldsymbol{b})
\exp[i\boldsymbol{q}\cdot\boldsymbol{l}]\\
    \hat{\boldsymbol{p}}(\boldsymbol{l}\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{N_0}} \sum_{\boldsymbol{q}} \hat{\boldsymbol{P}}
(\boldsymbol{q};\boldsymbol{b})
\exp[-i\boldsymbol{q}\cdot\boldsymbol{l}]
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{q}\)</span> is the
wavevector in the first Brillouin zone. The inverse of the above
equations are:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{\boldsymbol{X}} (\boldsymbol{q};\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{N_0}} \sum_{\boldsymbol{l}}
\hat{\boldsymbol{u}}(\boldsymbol{l}\boldsymbol{b})
\exp[-i\boldsymbol{q}\cdot\boldsymbol{l}]\\
    \hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{N_0}} \sum_{\boldsymbol{l}}
\hat{\boldsymbol{p}}(\boldsymbol{l}\boldsymbol{b})
\exp[i\boldsymbol{q}\cdot\boldsymbol{l}]
\end{aligned}
\]</span></p>
<p>Note the following properties:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{\boldsymbol{X}}^\dagger (\boldsymbol{q};\boldsymbol{b}) &amp;=
\hat{\boldsymbol{X}} (-\boldsymbol{q};\boldsymbol{b})\\
    \hat{\boldsymbol{P}}^\dagger (\boldsymbol{q};\boldsymbol{b}) &amp;=
\hat{\boldsymbol{P}} (-\boldsymbol{q};\boldsymbol{b})
\end{aligned}
\]</span></p>
<div class="note primary"><p>You may ask, that why the hell we use Fourier transform to obtain
<span class="math inline">\(\hat{\boldsymbol{X}}\)</span> and inverse
Fourier transform to obtain <span
class="math inline">\(\hat{\boldsymbol{P}}\)</span>. The answer is that,
we want to keep the canonical commutation relation between those two.
Using the relation that <span
class="math inline">\([\hat{\boldsymbol{u}}(\boldsymbol{l}\boldsymbol{b}),
\hat{\boldsymbol{p}}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)] =
i\hbar\delta_{\boldsymbol{l}\boldsymbol{l}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}\)</span>,
we know that:</p>
<p><span class="math display">\[
\begin{aligned}
    \left[\hat{X}_{\alpha} (\boldsymbol{q};\boldsymbol{b}),
\hat{P}_{\beta} (\boldsymbol{q&#39;};\boldsymbol{b&#39;})\right] &amp;=
\frac{1}{N_0} \sum_{\boldsymbol{l}} \sum_{\boldsymbol{l}&#39;}
\left[\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b}),
\hat{p}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)\right]
\exp[-i(\boldsymbol{q}\cdot\boldsymbol{l}-\boldsymbol{q}&#39;\cdot\boldsymbol{l}&#39;)]
\\
    &amp;= \frac{1}{N_0} \sum_{\boldsymbol{l}}
\sum_{\boldsymbol{l}&#39;}i\hbar
\delta_{\alpha\beta}\delta_{\boldsymbol{l}\boldsymbol{l}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}\exp[-i(\boldsymbol{q}\cdot\boldsymbol{l}-\boldsymbol{q}&#39;\cdot\boldsymbol{l}&#39;)]\\
    &amp;= \frac{1}{N_0} \delta_{\alpha\beta}\sum_{\boldsymbol{l}}i\hbar
\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}\exp[-i(\boldsymbol{q}-\boldsymbol{q}&#39;)\cdot\boldsymbol{l}]\\
    &amp;= i\hbar
\delta_{\alpha\beta}\delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}
\end{aligned}
\]</span></p>
<p>Also, the reason why we multiply <span
class="math inline">\(1/\sqrt{N_0}\)</span> in the transformation is
that, we want to obtain the above canonical commutation relation.</p>
</div>
<p>With the above equations, the Hamiltonian can be rewritten as:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{1st term} &amp;= \sum_{\boldsymbol{l}\boldsymbol{b}}
\frac{\hat{p}^2 (\boldsymbol{l}\boldsymbol{b})}{2m_{\boldsymbol{b}}}\\
    &amp;= \frac{1}{N_0}\sum_{\boldsymbol{l}\boldsymbol{b}}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;} \frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}(\boldsymbol{q}&#39;;\boldsymbol{b})
\exp[-i(\boldsymbol{q}+\boldsymbol{q}&#39;)\cdot\boldsymbol{l}]\\
    &amp;= \sum_{\boldsymbol{b}}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;} \frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}(\boldsymbol{q}&#39;;\boldsymbol{b})
\delta_{\boldsymbol{0},\boldsymbol{q}+\boldsymbol{q}&#39;}\\
    &amp;=
\sum_{\boldsymbol{q}\boldsymbol{b}}\frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}^\dagger (\boldsymbol{q};\boldsymbol{b})\\
    \text{2nd term} &amp;= \frac{1}{2}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;}
\sum_{\alpha\beta}
\Phi_{\alpha\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})
\hat{u}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)\\
    &amp;= \frac{1}{2}\frac{1}{N_0}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;}
\sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;}\Phi_{\alpha\beta}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;)   \hat{X}_{\alpha}
(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\exp[i\boldsymbol{q}\cdot\boldsymbol{l} +
i\boldsymbol{q}&#39;\cdot\boldsymbol{l}&#39;]\\
    &amp;= \frac{1}{2}
\frac{1}{N_0}\sum_{\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{\boldsymbol{l}\boldsymbol{h}} \sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;}
\Phi_{\alpha\beta}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{h}\boldsymbol{b}&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\exp[i(\boldsymbol{q}+\boldsymbol{q}&#39;)\cdot\boldsymbol{l}]\exp[i\boldsymbol{q}&#39;\cdot\boldsymbol{h}]\\
    &amp;= \frac{1}{2} \sum_{\alpha\beta} \sum_{\boldsymbol{q}}
\sum_{\boldsymbol{b}\boldsymbol{b}&#39;}
\underbrace{\sum_{\boldsymbol{h}}  \Phi_{\alpha\beta}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{h}\boldsymbol{b}&#39;)
\exp[-i\boldsymbol{q}\cdot\boldsymbol{h}]}_{\equiv
\Phi_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})}
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \hat{X}_{\beta}^\dagger
(\boldsymbol{q};\boldsymbol{b}&#39;) \\
    &amp;= \frac{1}{2} \sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\Phi_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \hat{X}_{\beta}^\dagger
(\boldsymbol{q};\boldsymbol{b}&#39;)\\
    \text{3rd term} &amp;= \frac{1}{3!}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;}
\sum_{\alpha\beta\gamma}
\Phi_{\alpha\beta\gamma}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{u}_{\alpha}(\boldsymbol{l}\boldsymbol{b})
\hat{u}_{\beta}(\boldsymbol{l}&#39;\boldsymbol{b}&#39;)
\hat{u}_{\gamma}(\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)\\
    &amp;= \frac{1}{3!}\frac{1}{N_0^{\frac{3}{2}}}
\sum_{\boldsymbol{l}\boldsymbol{b}\boldsymbol{l}&#39;\boldsymbol{b}&#39;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;}
\sum_{\alpha\beta\gamma}
\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{l}\boldsymbol{b};\boldsymbol{l}&#39;\boldsymbol{b}&#39;;\boldsymbol{l}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\exp[i\boldsymbol{q}\cdot\boldsymbol{l}+i\boldsymbol{q}&#39;\cdot\boldsymbol{l}&#39;+i\boldsymbol{q}&#39;&#39;\cdot\boldsymbol{l}&#39;&#39;]\\
    &amp;= \frac{1}{3!} \frac{1}{N_0^{\frac{3}{2}}}
\sum_{\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}\sum_{\boldsymbol{l}\boldsymbol{h}\boldsymbol{h}&#39;}
\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{h}\boldsymbol{b}&#39;;\boldsymbol{h}&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\exp[i(\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;)\cdot\boldsymbol{l}]\exp[i\boldsymbol{q}&#39;\cdot\boldsymbol{h}]\exp[i\boldsymbol{q}&#39;&#39;\cdot\boldsymbol{h}&#39;]\\
    &amp;= \frac{1}{3!} \frac{1}{\sqrt{N_0}}
\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}
\underbrace{\sum_{\boldsymbol{h}\boldsymbol{h}&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{0}\boldsymbol{b};\boldsymbol{h}\boldsymbol{b}&#39;;\boldsymbol{h}&#39;\boldsymbol{b}&#39;&#39;)
\exp[i\boldsymbol{q}&#39;\cdot\boldsymbol{h}]\exp[i\boldsymbol{q}&#39;&#39;\cdot\boldsymbol{h}&#39;]}_{\equiv
\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
}\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\delta_{\boldsymbol{G},\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}\\
    &amp;= \frac{1}{3!}
\frac{1}{\sqrt{N_0}}\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\delta_{\boldsymbol{G},\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{G}\)</span> is a
reciprocal lattice vector. Using the above derivations, the Hamiltonian
is thus expressed as,</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{H} &amp;=
\sum_{\boldsymbol{q}\boldsymbol{b}}\frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}^\dagger (\boldsymbol{q};\boldsymbol{b}) +
\frac{1}{2} \sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\Phi_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \hat{X}_{\beta}^\dagger
(\boldsymbol{q};\boldsymbol{b}&#39;) \\
    &amp;\quad + \frac{1}{3!}
\frac{1}{\sqrt{N_0}}\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\delta_{\boldsymbol{G},\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\end{aligned}
\]</span></p>
<h2 id="boldsymbolq-s-representation"><span
class="math inline">\((\boldsymbol{q}, s)\)</span> representation</h2>
<p>Now, we have just taken the first step of the Long March.</p>
<p>According to our experiences dealing with classical system (see the
<a href="/2023/10/phonon-dispersion/">previous post that solves the
classical harmonic oscillator</a>), there are <span
class="math inline">\(nd\)</span> distinct vibration modes for a crystal
with <span class="math inline">\(n\)</span> atoms in the unit cell, and
<span class="math inline">\(d\)</span> dimensions. And at the same time,
the eigenvectors that represent those modes are orthogonal to each
other. For the present case, we denote those eigenvectors as <span
class="math inline">\(\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)\)</span>,
where <span class="math inline">\(s\)</span> is phonon branch. It is
noteworthy that <span
class="math inline">\(\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)\)</span>
contains the magnitude, direction of vibration, as well as the phase of
the vibration. And it is normalized such that,</p>
<p><span class="math display">\[
\begin{aligned}
    \sum_{\boldsymbol{b}}
\boldsymbol{e}^*(\boldsymbol{b}|\boldsymbol{q}s)
\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s&#39;) &amp;=
\delta_{ss&#39;}\\
    \sum_s e_{\alpha}^*(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}s) &amp;=
\delta_{\alpha\beta}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}
\end{aligned}
\]</span></p>
<p>That is the inner product of two eigenvectors with the same
wavevector is 1 if they are the same mode, and 0 otherwise. Taken use of
this set of basis, we make another transformation:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{X}(\boldsymbol{q}s) &amp;= \sum_{\boldsymbol{b}}
\sqrt{m_{\boldsymbol{b}}}
\boldsymbol{e}^*(\boldsymbol{b}|\boldsymbol{q}s)
\hat{\boldsymbol{X}}(\boldsymbol{q};\boldsymbol{b})\\
    \hat{P}(\boldsymbol{q}s) &amp;= \sum_{\boldsymbol{b}}
\frac{1}{\sqrt{m_{\boldsymbol{b}}}}
\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)
\hat{\boldsymbol{P}}(\boldsymbol{q};\boldsymbol{b})
\end{aligned}
\]</span></p>
<div class="note primary"><p>Under this transformation, we still have the canonical commutation
relation:</p>
<p><span class="math display">\[
\begin{aligned}
    \left[\hat{X}(\boldsymbol{q}s), \hat{P}(\boldsymbol{q}&#39;s&#39;)
\right] &amp;= \sum_{\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{\alpha\beta}
\sqrt{\frac{m_{\boldsymbol{b}}}{m_{\boldsymbol{b}&#39;}}}
e^*_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}&#39;s&#39;)\left[\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}),\hat{P}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)\right]\\
    &amp;= \sum_{\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{\alpha\beta}e^*_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}&#39;s&#39;)
i\hbar
\delta_{\alpha\beta}\delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}\\
    &amp;= \sum_{\boldsymbol{b}}\sum_{\alpha}
e^*_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}&#39;s&#39;)
i\hbar \delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\\
    &amp;= i\hbar
\delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\delta_{ss&#39;}
\end{aligned}
\]</span></p>
</div>
<h2 id="annihilation-and-creation-operators">Annihilation and creation
operators</h2>
<p>Using <span class="math inline">\(\hat{X}(\boldsymbol{q}s)\)</span>
and <span class="math inline">\(\hat{P}(\boldsymbol{q}s)\)</span>, we
make the final transformation, called by the annihilation and creation
operators:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{a}_{\boldsymbol{q}s} &amp;=
\frac{1}{\sqrt{2\hbar\omega(\boldsymbol{q}s)}}\hat{P}(\boldsymbol{q}s) -
i \sqrt{\frac{\omega (\boldsymbol{q}s)}{2\hbar}} \hat{X}^\dagger
(\boldsymbol{q}s)\\
    \hat{a}^\dagger_{\boldsymbol{q}s} &amp;=
\frac{1}{\sqrt{2\hbar\omega(\boldsymbol{q}s)}}\hat{P}^\dagger(\boldsymbol{q}s)
+ i \sqrt{\frac{\omega (\boldsymbol{q}s)}{2\hbar}} \hat{X}
(\boldsymbol{q}s)
\end{aligned}
\]</span></p>
<div class="note primary"><p>You would ask, why the hell they are called annihilation and creation
operators? The answer is that, they actually annihilate or create a
phonon. To see this, I refer you to the next section.</p>
</div>
<p>where <span class="math inline">\(\omega(\boldsymbol{q}s)\)</span> is
the frequency of the phonon mode <span
class="math inline">\((\boldsymbol{q}s)\)</span>. By such definition,
using the relations that <span
class="math inline">\(\hat{X}(\boldsymbol{q}s)^\dagger =
\hat{X}(-\boldsymbol{q}s), \hat{P}(\boldsymbol{q}s)^\dagger =
\hat{P}(-\boldsymbol{q}s)\)</span>, and that <span
class="math inline">\(\omega(\boldsymbol{q}s)=\omega(-\boldsymbol{q}s)\)</span>,
the inverse transformation is:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{X}(\boldsymbol{q}s) &amp;=
-i\sqrt{\frac{\hbar}{2\omega(\boldsymbol{q}s)}}
(\hat{a}^\dagger_{\boldsymbol{q}s} - \hat{a}_{-\boldsymbol{q}s})\\
    \hat{P}(\boldsymbol{q}s) &amp;=
\sqrt{\frac{\hbar\omega(\boldsymbol{q}s)}{2}} (\hat{a}_{\boldsymbol{q}s}
+ \hat{a}_{-\boldsymbol{q}s}^\dagger)
\end{aligned}
\]</span></p>
<p>In addition, the annihilation operator and the creation operator
satisfy the following commutation relation:</p>
<p><span class="math display">\[
\begin{aligned}
    \left[\hat{a}_{\boldsymbol{q}s},\hat{a}_{\boldsymbol{q}&#39;s&#39;}^\dagger\right]
&amp;=  \frac{1}{2\hbar\sqrt{\omega(\boldsymbol{q}s)\omega(\boldsymbol{q}&#39;s&#39;)}}\left[\hat{P}(\boldsymbol{q}s),\hat{P}^\dagger(\boldsymbol{q}&#39;s&#39;)\right]
+
\frac{\sqrt{\omega(\boldsymbol{q}s)\omega(\boldsymbol{q}&#39;s&#39;)}}{2\hbar}\left[\hat{X}(\boldsymbol{q}s),\hat{X}^\dagger(\boldsymbol{q}&#39;s&#39;)\right]
\\
    &amp;\qquad - \frac{i}{2\hbar}\sqrt{\frac{\omega
(\boldsymbol{q}s)}{\omega (\boldsymbol{q}&#39;s&#39;)}}
\left[\hat{X}^\dagger(\boldsymbol{q}s),
\hat{P}^\dagger(\boldsymbol{q}&#39;s&#39;)\right] +
\frac{i}{2\hbar}\sqrt{\frac{\omega (\boldsymbol{q}&#39;s&#39;)}{\omega
(\boldsymbol{q}s)}}
\left[\hat{P}(\boldsymbol{q}s),\hat{X}(\boldsymbol{q}&#39;s&#39;)
\right]\\
    &amp;= \delta_{\boldsymbol{q}\boldsymbol{q}&#39;}\delta_{ss&#39;}
\end{aligned}
\]</span></p>
<p>Looking back at the <span
class="math inline">\((\boldsymbol{q},\boldsymbol{b})\)</span>
representations, we have:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{\boldsymbol{X}}(\boldsymbol{q};\boldsymbol{b}) &amp;=
\frac{1}{\sqrt{m_{\boldsymbol{b}}}}\sum_s
\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s) \hat{X}(\boldsymbol{q}s)
= -i \sum_s \sqrt{\frac{\hbar}{2 m_{\boldsymbol{b}}\omega
(\boldsymbol{q}s)}} \boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)
(\hat{a}_{\boldsymbol{q}s}^\dagger - \hat{a}_{-\boldsymbol{q}s})\\
    \hat{\boldsymbol{P}}(\boldsymbol{q};\boldsymbol{b}) &amp;=
\sqrt{m_{\boldsymbol{b}}}\sum_s
\boldsymbol{e}^*(\boldsymbol{b}|\boldsymbol{q}s)
\hat{P}(\boldsymbol{q}s) = \sum_s \sqrt{\frac{\hbar
m_{\boldsymbol{b}}\omega (\boldsymbol{q}s)}{2}}
\boldsymbol{e}^*(\boldsymbol{b}|\boldsymbol{q}s)
(\hat{a}_{\boldsymbol{q}s} + \hat{a}_{-\boldsymbol{q}s}^\dagger)
\end{aligned}
\]</span></p>
<p>The Hamiltonian can thus be rewritten as:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{1st term} &amp;=
\sum_{\boldsymbol{q}\boldsymbol{b}}\frac{1}{2m_{\boldsymbol{b}}}
\hat{\boldsymbol{P}} (\boldsymbol{q};\boldsymbol{b})
\hat{\boldsymbol{P}}^\dagger (\boldsymbol{q};\boldsymbol{b}) \\
    &amp;= \frac{1}{4}\sum_{\boldsymbol{q}\boldsymbol{b}}
\sum_{ss&#39;}\sum_{\alpha\beta} \hbar\omega (\boldsymbol{q}s)
e^*_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}(\boldsymbol{b}|\boldsymbol{q}s&#39;)
\left(\hat{a}_{\boldsymbol{q}s} +
\hat{a}_{-\boldsymbol{q}s}^\dagger\right)
\left(\hat{a}^\dagger_{\boldsymbol{q}s&#39;} +
\hat{a}_{-\boldsymbol{q}s&#39;}\right)\\
    &amp;= \frac{1}{4} \sum_{\boldsymbol{q}} \sum_{s} h\omega
(\boldsymbol{q}s) \left(\hat{a}_{\boldsymbol{q}s} +
\hat{a}_{-\boldsymbol{q}s}^\dagger\right)
\left(\hat{a}^\dagger_{\boldsymbol{q}s&#39;} +
\hat{a}_{-\boldsymbol{q}s&#39;}\right)\\
    \text{2nd term} &amp;= \frac{1}{2} \sum_{\alpha\beta}
\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\Phi_{\alpha\beta}(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b}) \hat{X}_{\beta}^\dagger
(\boldsymbol{q};\boldsymbol{b}&#39;) \\
    &amp;= \frac{1}{2}
\sum_{\alpha\beta}\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{ss&#39;} \Phi_{\alpha\beta}
(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\frac{\hbar}{2\sqrt{m_{\boldsymbol{b}}m_{\boldsymbol{b}&#39;}\omega
(\boldsymbol{q}s)\omega (\boldsymbol{q}s&#39;)}}
e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}^*(\boldsymbol{b}&#39;|\boldsymbol{q}s&#39;)
\left(\hat{a}_{\boldsymbol{q}s}^\dagger -
\hat{a}_{-\boldsymbol{q}s}\right) \left(\hat{a}_{\boldsymbol{q}s&#39;} -
\hat{a}^\dagger_{-\boldsymbol{q}s&#39;}\right)\\
    &amp;= \frac{1}{2}
\sum_{\alpha\beta}\sum_{\boldsymbol{q}\boldsymbol{b}\boldsymbol{b}&#39;}
\sum_{ss&#39;} D_{\alpha\beta}^\dagger
(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q})
\frac{\hbar}{2\sqrt{\omega (\boldsymbol{q}s)\omega
(\boldsymbol{q}s&#39;)}} e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}^*(\boldsymbol{b}&#39;|\boldsymbol{q}s&#39;)
\left(\hat{a}_{\boldsymbol{q}s}^\dagger -
\hat{a}_{-\boldsymbol{q}s}\right) \left(\hat{a}_{\boldsymbol{q}s&#39;} -
\hat{a}^\dagger_{-\boldsymbol{q}s&#39;}\right)\\
    &amp; = \frac{1}{4} \sum_{\boldsymbol{q}s} \hbar\omega
(\boldsymbol{q}s) \left(\hat{a}_{\boldsymbol{q}s}^\dagger -
\hat{a}_{-\boldsymbol{q}s}\right) \left(\hat{a}_{\boldsymbol{q}s} -
\hat{a}^\dagger_{-\boldsymbol{q}s}\right)
\end{aligned}
\]</span></p>
<p>The derivation of the 2nd term uses the fact that <span
class="math inline">\(\boldsymbol{e}(\boldsymbol{b}|\boldsymbol{q}s)\)</span>
is the eigenvector of <span
class="math inline">\(\boldsymbol{D}(\boldsymbol{q})\)</span> (the
dynamical matrix, see <a href="/2023/10/phonon-dispersion">the previous
post</a>), and the corresponding eigenvalue is <span
class="math inline">\(\omega (\boldsymbol{q}s)^2\)</span>.</p>
<div class="note warning"><p>Above, the summation over <span class="math inline">\(s&#39;\)</span>
in the second term is cancelled due to the orthogonality of the
eigenvectors for the summation over <span
class="math inline">\(\alpha\)</span> and <span
class="math inline">\(\beta\)</span>. Specifically,</p>
<p><span class="math display">\[
\begin{aligned}
    \sum_{\boldsymbol{b}\boldsymbol{b}&#39;}\sum_{\alpha,\beta}
D_{\alpha\beta}^{\dagger}
(\boldsymbol{b}\boldsymbol{b}&#39;|\boldsymbol{q}) e_{\alpha}
(\boldsymbol{b}|\boldsymbol{q}s) e_{\beta}^*
(\boldsymbol{b}&#39;|\boldsymbol{q}s&#39;) &amp;= \omega^2
(\boldsymbol{q}s&#39;)
\sum_{\boldsymbol{b}\boldsymbol{b}&#39;}\sum_{\alpha,\beta} e_{\alpha}
(\boldsymbol{b}|\boldsymbol{q}s) e_{\beta}^*
(\boldsymbol{b}&#39;|\boldsymbol{q}s&#39;)\\
    &amp;= \omega^2 (\boldsymbol{q}s&#39;) \delta_{ss&#39;}
\delta_{\boldsymbol{b}\boldsymbol{b}&#39;}
\end{aligned}
\]</span></p>
</div>
<p>As for the 3rd term, we have:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{3rd term} &amp;= \frac{1}{3!}
\frac{1}{\sqrt{N_0}}\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}
\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
\hat{X}_{\alpha}(\boldsymbol{q};\boldsymbol{b})
\hat{X}_{\beta}(\boldsymbol{q}&#39;;\boldsymbol{b}&#39;)
\hat{X}_{\gamma}(\boldsymbol{q}&#39;&#39;;\boldsymbol{b}&#39;&#39;)
\delta_{\boldsymbol{G},\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}\\
    &amp;= \frac{1}{3!}\frac{1}{\sqrt{N_0}}
\sum_{\alpha\beta\gamma}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
i
\sqrt{\frac{\hbar^3}{8m_{\boldsymbol{b}}m_{\boldsymbol{b}&#39;}m_{\boldsymbol{b}&#39;&#39;}\omega
(\boldsymbol{q}s)\omega (\boldsymbol{q}&#39;s&#39;)\omega
(\boldsymbol{q}&#39;&#39;s&#39;&#39;)}}\Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}&#39;s&#39;)
e_{\gamma}(\boldsymbol{b}&#39;&#39;|\boldsymbol{q}&#39;&#39;s&#39;&#39;)
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)\\
    &amp;=
\frac{1}{3!}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
\underbrace{\sum_{\alpha\beta\gamma\boldsymbol{b}\boldsymbol{b}&#39;\boldsymbol{b}&#39;&#39;}\frac{i}{\sqrt{N_0}}
\sqrt{\frac{\hbar^3}{8m_{\boldsymbol{b}}m_{\boldsymbol{b}&#39;}m_{\boldsymbol{b}&#39;&#39;}\omega
(\boldsymbol{q}s)\omega (\boldsymbol{q}&#39;s&#39;)\omega
(\boldsymbol{q}&#39;&#39;s&#39;&#39;)}}  \Phi_{\alpha\beta\gamma}(\boldsymbol{q}\boldsymbol{b},
\boldsymbol{q}&#39;\boldsymbol{b}&#39;,
\boldsymbol{q}&#39;&#39;\boldsymbol{b}&#39;&#39;)
e_{\alpha}(\boldsymbol{b}|\boldsymbol{q}s)
e_{\beta}(\boldsymbol{b}&#39;|\boldsymbol{q}&#39;s&#39;)
e_{\gamma}(\boldsymbol{b}&#39;&#39;|\boldsymbol{q}&#39;&#39;s&#39;&#39;)
}_{\equiv \Phi
(\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)}
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)\\
    &amp;=
\frac{1}{3!}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
\Phi
(\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)
\end{aligned}
\]</span></p>
<p>To summarize the results by far, we see the Hamiltonian is expressed
as:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{H} &amp;= \frac{1}{4} \sum_{\boldsymbol{q}s} \hbar\omega
(\boldsymbol{q}s) \left(\hat{a}_{\boldsymbol{q}s} +
\hat{a}_{-\boldsymbol{q}s}^\dagger\right)
\left(\hat{a}^\dagger_{\boldsymbol{q}s&#39;} +
\hat{a}_{-\boldsymbol{q}s&#39;}\right) +  \frac{1}{4}
\sum_{\boldsymbol{q}s} \hbar\omega (\boldsymbol{q}s)
\left(\hat{a}_{\boldsymbol{q}s}^\dagger -
\hat{a}_{-\boldsymbol{q}s}\right) \left(\hat{a}_{\boldsymbol{q}s} -
\hat{a}^\dagger_{-\boldsymbol{q}s}\right)\\
    &amp;\qquad +
\frac{1}{3!}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
\Phi
(\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)\\
    &amp;= \sum_{\boldsymbol{q}s} \hbar\omega (\boldsymbol{q}s)
\left(\hat{a}^\dagger_{\boldsymbol{q}s} a_{\boldsymbol{q}s} +
\frac{1}{2}\right) \\
    &amp;\qquad +
\frac{1}{3!}\sum_{\boldsymbol{q}\boldsymbol{q}&#39;\boldsymbol{q}&#39;&#39;}\sum_{ss&#39;s&#39;&#39;}
\Phi
(\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)
\delta_{G,\boldsymbol{q}+\boldsymbol{q}&#39;+\boldsymbol{q}&#39;&#39;}
\left(\hat{a}^\dagger_{\boldsymbol{q}s}-\hat{a}_{-\boldsymbol{q}s}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;s&#39;}-\hat{a}_{-\boldsymbol{q}&#39;s&#39;}\right)\left(\hat{a}^\dagger_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}-\hat{a}_{-\boldsymbol{q}&#39;&#39;s&#39;&#39;}\right)
\end{aligned}
\]</span></p>
<h1 id="harmonic-oscillator">Harmonic oscillator</h1>
<p>Let's see what the present results can do. First, we ignore the
already-derived third-order term in the Hamiltonian, and focus on the
harmonic potential. We have:</p>
<p><span class="math display">\[
\hat{H}_{\text{harm}} = \sum_{\boldsymbol{q}s} \hbar\omega
(\boldsymbol{q}s) \left(\hat{a}^\dagger_{\boldsymbol{q}s}
\hat{a}_{\boldsymbol{q}s} + \frac{1}{2}\right)
\]</span></p>
<p>Seems to be familiar? Yes, the energy of phonons is just derived from
this equation. As well as the quantization of phonon! We recall the
many-body SchrÃ¶dinger equation, say there is a state <span
class="math inline">\(\Psi\)</span>, whose energy is <span
class="math inline">\(E\)</span>, thus <span
class="math inline">\(\hat{H}_{\text{harm}}\Psi = E\Psi\)</span>. After
using the annihilator or the creation operator, we have:</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{H}_{\text{harm}}(\hat{a}_{\boldsymbol{q}s}\Psi) &amp;=
\hbar\omega (\boldsymbol{q}s)  \left(\hat{a}^\dagger_{\boldsymbol{q}s}
\hat{a}_{\boldsymbol{q}s} + \frac{1}{2}\right) \hat{a}_{\boldsymbol{q}s}
\Psi = \hbar \omega(\boldsymbol{q}s)
\left(\hat{a}_{\boldsymbol{q}s}\hat{a}_{\boldsymbol{q}s}^\dagger
\hat{a}_{\boldsymbol{q}s} - \frac{1}{2}\hat{a}_{\boldsymbol{q}s}\right)
\Psi\\
    &amp;= \hat{a}_{\boldsymbol{q}s}\left(\hat{H}-\hbar\omega
(\boldsymbol{q}s)\right) \Psi = (E-\hbar\omega
(\boldsymbol{q}s))(\hat{a}_{\boldsymbol{q}s}\Psi)\\
    \hat{H}_{\text{harm}}(\hat{a}^\dagger_{\boldsymbol{q}s}\Psi) &amp;=
\hbar\omega (\boldsymbol{q}s)  \left(\hat{a}^\dagger_{\boldsymbol{q}s}
\hat{a}_{\boldsymbol{q}s} + \frac{1}{2}\right)
\hat{a}^\dagger_{\boldsymbol{q}s} \Psi = \hbar \omega(\boldsymbol{q}s)
\left(\hat{a}^\dagger_{\boldsymbol{q}s}\hat{a}_{\boldsymbol{q}s}
\hat{a}^\dagger_{\boldsymbol{q}s} +
\frac{1}{2}\hat{a}^\dagger_{\boldsymbol{q}s}\right) \Psi\\
    &amp;= \hat{a}^\dagger_{\boldsymbol{q}s}\left( \hat{H}+\hbar\omega
(\boldsymbol{q}s)\right) \Psi = (E+\hbar\omega
(\boldsymbol{q}s))(\hat{a}^\dagger_{\boldsymbol{q}s}\Psi)
\end{aligned}
\]</span></p>
<p>That is to say, through the action of the annihilation or the
creation operator, the energy of the state is changed by <span
class="math inline">\(\pm\hbar\omega (\boldsymbol{q}s)\)</span>. And the
energy of the state is quantized, that is, <span class="math inline">\(E
= \hbar\omega (\boldsymbol{q}s) n_{\boldsymbol{q}s} +
\frac{1}{2}\hbar\omega (\boldsymbol{q}s)\)</span>, where <span
class="math inline">\(n_{\boldsymbol{q}s}\)</span> is the number of
phonons in the state <span
class="math inline">\((\boldsymbol{q}s)\)</span>.</p>
<p>If we use <span
class="math inline">\(\Ket{n_{\boldsymbol{q}s}}\)</span> (normalized
eigenvector) to denote the state with <span
class="math inline">\(n_{\boldsymbol{q}s}\)</span> phonons in the state
<span class="math inline">\((\boldsymbol{q}s)\)</span>, we know
that,</p>
<p><span class="math display">\[
\begin{aligned}
    \hat{a}_{\boldsymbol{q}s}\Ket{n_{\boldsymbol{q}s}} &amp;\propto
\Ket{n_{\boldsymbol{q}s}-1}\\
    \hat{a}^\dagger_{\boldsymbol{q}s}\Ket{n_{\boldsymbol{q}s}}
&amp;\propto \Ket{n_{\boldsymbol{q}s}+1}
\end{aligned}
\]</span></p>
<p>But the proportionality constant is not known yet. Due to SchrÃ¶dinger
equation,</p>
<p><span class="math display">\[
\bra{n_{\boldsymbol{q}s}} \hat{a}_{\boldsymbol{q}s}^\dagger
\hat{a}_{\boldsymbol{q}s} \ket{n_{\boldsymbol{q}s}} =
n_{\boldsymbol{q}s} = n_{\boldsymbol{q}s}
\braket{n_{\boldsymbol{q}s}-1|n_{\boldsymbol{q}s}-1}
\]</span></p>
<p>Thus <span
class="math inline">\(\hat{a}_{\boldsymbol{q}s}\ket{n_{\boldsymbol{q}s}}
= \sqrt{n_{\boldsymbol{q}s}}\ket{n_{\boldsymbol{q}s}-1}\)</span>.
Similarly we can obtain that <span
class="math inline">\(\hat{a}^\dagger_{\boldsymbol{q}s}\ket{n_{\boldsymbol{q}s}}
= \sqrt{n_{\boldsymbol{q}s}+1}\ket{n_{\boldsymbol{q}s}+1}\)</span>.</p>
<h1 id="three-phonon-scattering">Three-phonon scattering</h1>
<p>Three-phonon scattering can be computed by the third-order term in
the Hamiltonian using Fermi's golden rule, which calculates the
transition rate between initial state <span
class="math inline">\(i\)</span> and final state <span
class="math inline">\(j\)</span> by:</p>
<p><span class="math display">\[
P_{i\rightarrow j} = \frac{2\pi}{\hbar}
\big|\bra{i}\mathcal{V}_3\ket{j}\big|^2 \delta(E_i-E_j)
\]</span></p>
<p>There are two classes of three-phonon scattering:</p>
<ul>
<li>Class 1: <span
class="math inline">\(\boldsymbol{q}+\boldsymbol{q}&#39; \rightarrow
\boldsymbol{q}&#39;&#39;\)</span></li>
<li>Class 2: <span
class="math inline">\(\boldsymbol{q}\rightarrow\boldsymbol{q}&#39; +
\boldsymbol{q}&#39;&#39;\)</span></li>
</ul>
<p>For class 1, the scattering is given by:</p>
<p><span class="math display">\[
\begin{aligned}
    P_{\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;\rightarrow
\boldsymbol{q}&#39;&#39;s&#39;&#39;} &amp;= \frac{2\pi}{\hbar}
\big|\bra{n_{\boldsymbol{q}s}-1,n_{\boldsymbol{q}&#39;s&#39;}-1,n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}+1}\mathcal{V}_3\ket{n_{\boldsymbol{q}s},n_{\boldsymbol{q}&#39;s&#39;},n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}}\big|^2\delta
(\omega(\boldsymbol{q}s)+\omega(\boldsymbol{q}&#39;s&#39;)-\omega(\boldsymbol{q}&#39;&#39;s&#39;&#39;))\\
    &amp;= \frac{2\pi}{\hbar}
\big|\Phi(-\boldsymbol{q}s,-\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)\big|^2
n_{\boldsymbol{q}s}n_{\boldsymbol{q}&#39;s&#39;}
(n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}+1)\delta
(\omega(\boldsymbol{q}s)+\omega(\boldsymbol{q}&#39;s&#39;)-\omega(\boldsymbol{q}&#39;&#39;s&#39;&#39;))
\end{aligned}
\]</span></p>
<p>The net scattering rate is:</p>
<p><span class="math display">\[
\begin{aligned}
    P_{\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;\rightarrow
\boldsymbol{q}&#39;&#39;s&#39;&#39;} -
P_{\boldsymbol{q}&#39;&#39;s&#39;&#39;,\rightarrow
\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;} &amp;= \frac{2\pi}{\hbar}
\big|\Phi(-\boldsymbol{q}s,-\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;)\big|^2
\delta
(\omega(\boldsymbol{q}s)+\omega(\boldsymbol{q}&#39;s&#39;)-\omega(\boldsymbol{q}&#39;&#39;s&#39;&#39;))\\
    &amp;\quad \times
\Big[n_{\boldsymbol{q}s}n_{\boldsymbol{q}&#39;s&#39;}
(n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}+1) -
(n_{\boldsymbol{q}s}+1)(n_{\boldsymbol{q}&#39;s&#39;}+1)
n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;} \Big]
\end{aligned}
\]</span></p>
<p>Similarly, for class 2, the scattering is given by:</p>
<p><span class="math display">\[
\begin{aligned}
    P_{\boldsymbol{q}s\rightarrow
\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;} -
P_{\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;
\rightarrow \boldsymbol{q}s} &amp;= \frac{2\pi}{\hbar}
\big|\Phi(\boldsymbol{q}s,-\boldsymbol{q}&#39;s&#39;,-\boldsymbol{q}&#39;&#39;s&#39;&#39;)\big|^2
\delta
(\omega(\boldsymbol{q}s)-\omega(\boldsymbol{q}&#39;s&#39;)-\omega(\boldsymbol{q}&#39;&#39;s&#39;&#39;))\\
    &amp;\quad \times \Big[n_{\boldsymbol{q}s}
(n_{\boldsymbol{q}&#39;s&#39;}+1)
(n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}+1) -
(n_{\boldsymbol{q}s}+1)n_{\boldsymbol{q}&#39;s&#39;}n_{\boldsymbol{q}&#39;&#39;s&#39;&#39;}\Big]
\end{aligned}
\]</span></p>
<p>Yielding the net three-phonon scattering rate,</p>
<p><span class="math display">\[
\begin{aligned}
    -\left(\frac{\partial n_{\boldsymbol{q}s}}{\partial
t}\right)_{\text{scatt}} &amp;=
\sum_{\boldsymbol{q}&#39;s&#39;\boldsymbol{q}&#39;&#39;s&#39;&#39;}
\left[(P_{\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;\rightarrow
\boldsymbol{q}&#39;&#39;s&#39;&#39;} -
P_{\boldsymbol{q}&#39;&#39;s&#39;&#39;,\rightarrow
\boldsymbol{q}s,\boldsymbol{q}&#39;s&#39;})  +  \frac{1}{2}
(P_{\boldsymbol{q}s\rightarrow
\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;} -
P_{\boldsymbol{q}&#39;s&#39;,\boldsymbol{q}&#39;&#39;s&#39;&#39;
\rightarrow \boldsymbol{q}s})\right]
\end{aligned}
\]</span></p>
<p>where the factor <span class="math inline">\(\frac{1}{2}\)</span> is
to avoid double counting.</p>
<h1 id="references">References</h1>
<ol type="1">
<li>Griffiths's <em>Introduction to quantum mechanics</em>.</li>
<li>Srivastava <em>The Physics of Phonons</em>.</li>
<li>Garg's PhD thesis <em>Thermal Conductivity from First-Principles in
Bulk, Disordered, and Nanostructured Materials</em> (MIT 2011).</li>
</ol>
]]></content>
      <categories>
        <category>Solid State Physics</category>
      </categories>
      <tags>
        <tag>Phonon</tag>
        <tag>Interatomic force constant</tag>
        <tag>Fermi&#39;s golden rule</tag>
        <tag>Scattering</tag>
      </tags>
  </entry>
</search>
